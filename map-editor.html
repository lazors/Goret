<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GORET - Standalone Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            overflow: hidden;
        }

        .editor-container {
            display: flex;
            height: 100vh;
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background: #0f1419;
        }

        #mapCanvas {
            display: block;
            cursor: crosshair;
            background: #1e3a5f;
        }

        .control-panel {
            width: 350px;
            background: rgba(30, 60, 95, 0.95);
            backdrop-filter: blur(10px);
            border-left: 2px solid #3498db;
            padding: 20px;
            overflow-y: auto;
        }

        .panel-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(52, 73, 94, 0.7);
            border-radius: 8px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .panel-title::before {
            content: "üó∫Ô∏è";
            margin-right: 8px;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(45deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        .btn-success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        .btn-warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-warning:hover {
            background: linear-gradient(45deg, #e67e22, #f39c12);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #7f8c8d, #95a5a6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(149, 165, 166, 0.4);
        }

        .btn-secondary:disabled {
            background: linear-gradient(45deg, #bdc3c7, #95a5a6);
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .input-group {
            margin: 10px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #bdc3c7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 4px;
            background: rgba(44, 62, 80, 0.8);
            color: #ecf0f1;
            font-size: 14px;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.3);
        }
        
        .section-header {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            border-radius: 4px;
            padding: 8px 12px;
            margin: 15px 0 10px 0;
            font-size: 14px;
            font-weight: bold;
            color: #3498db;
            text-align: center;
        }
        
        .input-row {
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }

        .status-indicator {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
            text-align: center;
            font-weight: bold;
        }

        .status-success {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            color: #2ecc71;
        }

        .status-info {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            color: #3498db;
        }

        .status-warning {
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid #f39c12;
            color: #f39c12;
        }

        .collision-points-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(44, 62, 80, 0.5);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .collision-point {
            padding: 5px 8px;
            margin: 2px 0;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border-left: 3px solid #3498db;
        }

        .collision-point.selected {
            background: rgba(231, 76, 60, 0.2);
            border-left-color: #e74c3c;
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 350px;
            background: rgba(30, 60, 95, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-bottom: 2px solid #3498db;
            z-index: 1000;
        }

        .header h1 {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
            margin: 0;
        }

        .header .subtitle {
            font-size: 12px;
            color: #bdc3c7;
            margin-top: 5px;
        }

        .canvas-wrapper {
            margin-top: 80px;
            height: calc(100vh - 80px);
            overflow: auto;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .zoom-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: scale(1.1);
        }

        .coordinates-display {
            position: absolute;
            top: 90px;
            left: 20px;
            background: rgba(44, 62, 80, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .file-input {
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(44, 62, 80, 0.5);
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .pulsing {
            animation: pulse 1.5s infinite;
        }
        
        kbd {
            background: rgba(44, 62, 80, 0.8);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 3px;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #3498db;
            margin: 0 2px;
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="canvas-area">
            <div class="header">
                <h1>üó∫Ô∏è GORET Map Editor</h1>
                <div class="subtitle">Standalone Map & Collision Editor</div>
            </div>
            
            <div class="coordinates-display" id="coordinatesDisplay">
                Mouse: (0, 0) | World: (0, 0)
            </div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="mapEditor.zoomIn()">+</button>
                <button class="zoom-btn" onclick="mapEditor.zoomOut()">-</button>
                <button class="zoom-btn" onclick="mapEditor.resetZoom()">‚åÇ</button>
            </div>
            
            <div class="canvas-wrapper">
                <canvas id="mapCanvas" width="1600" height="1000"></canvas>
            </div>
        </div>
        
        <div class="control-panel">
            <!-- Island Management -->
            <div class="panel-section">
                <div class="panel-title">Island Management</div>
                
                <input type="file" id="imageInput" class="file-input" accept="image/*">
                <button class="btn btn-primary" onclick="document.getElementById('imageInput').click()">
                    üìÅ Load Island Image
                </button>
                
                <!-- Island Editor Section -->
                <div class="section-header">üèùÔ∏è Island Editor</div>
                
                <div class="input-group">
                    <label>Island Name</label>
                    <select id="islandName">
                        <option value="__new__">+ Add New Island</option>
                        <option value="Saint Kitts" selected>Saint Kitts</option>
                    </select>
                    <input type="text" id="newIslandName" placeholder="Enter new island name" style="display: none; margin-top: 5px;">
                </div>
                
                <!-- Position Controls -->
                <div class="section-header">üìç Position</div>
                <div class="input-row">
                    <div class="input-group" style="flex: 1; margin-right: 10px;">
                        <label>X</label>
                        <input type="number" id="islandX" value="0" oninput="mapEditor.updateIslandProperty('x', this.value)">
                    </div>
                    <div class="input-group" style="flex: 1;">
                        <label>Y</label>
                        <input type="number" id="islandY" value="0" oninput="mapEditor.updateIslandProperty('y', this.value)">
                    </div>
                </div>
                
                <!-- Image Dimensions -->
                <div class="section-header">üìê Image Dimensions</div>
                <div class="input-row">
                    <div class="input-group" style="flex: 1; margin-right: 10px;">
                        <label>Width</label>
                        <input type="number" id="islandWidth" value="800" min="100" max="2000" oninput="mapEditor.updateIslandProperty('width', this.value)">
                    </div>
                    <div class="input-group" style="flex: 1;">
                        <label>Height</label>
                        <input type="number" id="islandHeight" value="600" min="100" max="2000" oninput="mapEditor.updateIslandProperty('height', this.value)">
                    </div>
                </div>
                
                <button class="btn btn-info" onclick="mapEditor.resetImageDimensions()" style="width: 100%; margin-top: 5px;">
                    üîÑ Reset to Original Size
                </button>
                
                <!-- Rotation -->
                <div class="section-header">üîÑ Rotation</div>
                <div class="input-group">
                    <label>Rotation (degrees)</label>
                    <input type="range" id="islandRotation" min="0" max="360" value="0" oninput="mapEditor.updateRotation(this.value)">
                    <input type="number" id="islandRotationValue" min="0" max="360" value="0" style="width: 60px; margin-left: 10px;" oninput="mapEditor.updateRotation(this.value)">
                </div>
                
                <div class="input-row" style="margin-top: 5px;">
                    <button class="btn btn-secondary" onclick="mapEditor.rotateIsland(-90)" style="flex: 1; margin-right: 5px;">‚Ü∫ -90¬∞</button>
                    <button class="btn btn-secondary" onclick="mapEditor.rotateIsland(90)" style="flex: 1;">‚Üª +90¬∞</button>
                </div>
                
                <!-- Collision -->
                <div class="section-header">üí• Collision</div>
                <div class="input-group">
                    <label>Radius (collision)</label>
                    <input type="number" id="islandRadius" value="150" oninput="mapEditor.updateIslandProperty('radius', this.value)">
                </div>
                
                <button class="btn btn-success" onclick="mapEditor.addIsland()">
                    ‚ûï Add Island
                </button>
                
                <button class="btn btn-warning" onclick="mapEditor.downloadSelectedIslandImage()" id="downloadImageBtn" style="display: none;">
                    üíæ Download Island Image
                </button>
                
                <button class="btn btn-info" onclick="mapEditor.saveIslandConfiguration()" id="saveIslandBtn" style="display: none;" title="Generate island configuration for Agent integration">
                    üíæ Save Island Config
                </button>
                
                <button class="btn btn-secondary" onclick="mapEditor.undo()" id="undoBtn" title="Undo last action (Ctrl+Z)">
                    ‚Ü∂ Undo
                </button>
            </div>
            
            <!-- Collision Editing -->
            <div class="panel-section">
                <div class="panel-title">Collision Editor</div>
                
                <div class="input-group">
                    <label>Select Island</label>
                    <select id="islandSelector" onchange="mapEditor.selectIsland()">
                        <option value="">-- Select Island --</option>
                    </select>
                </div>
                
                <button class="btn btn-primary" onclick="mapEditor.addCollisionPoint()">
                    üìç Add Point
                </button>
                
                <button class="btn btn-warning" onclick="mapEditor.optimizePoints()">
                    ‚ö° Basic Optimize
                </button>
                
                <button class="btn btn-warning" onclick="mapEditor.advancedOptimizePoints()" title="Advanced collision optimization with multiple algorithms">
                    üîß Advanced Optimize
                </button>
                
                <button class="btn btn-danger" onclick="mapEditor.clearCollision()">
                    üóëÔ∏è Clear Points
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.toggleCollisionLineMode()" id="collisionLineModeBtn">
                    ‚úèÔ∏è Draw Collision Line
                </button>
                
                <div class="collision-points-list" id="collisionPointsList">
                    <div style="text-align: center; color: #7f8c8d; font-style: italic;">
                        Select an island to edit collision points
                    </div>
                </div>
            </div>
            
            <!-- World Display -->
            <div class="panel-section">
                <div class="panel-title">üåç World Display</div>
                
                <button class="btn btn-primary" onclick="mapEditor.resetToWorldView()">
                    üåç Show Full World
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.toggleWorldBackground()" id="worldBackgroundBtn">
                    üåä Hide Ocean
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.toggleWorldBounds()" id="worldBoundsBtn">
                    üìé Hide Boundaries
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.toggleOceanWaves()" id="oceanWavesBtn">
                    üåä Show Waves
                </button>
            </div>
            
            <!-- Tools -->
            <div class="panel-section">
                <div class="panel-title">Tools</div>
                
                <button class="btn btn-primary" onclick="mapEditor.resetView()">
                    üéØ Reset View
                </button>
                
                <button class="btn btn-secondary" onclick="mapEditor.rotateSelected(90)" title="Rotate selected island 90¬∞ clockwise">
                    ‚Üª Rotate 90¬∞
                </button>
                
                <button class="btn btn-secondary" onclick="mapEditor.rotateSelected(-90)" title="Rotate selected island 90¬∞ counter-clockwise">
                    ‚Ü∫ Rotate -90¬∞
                </button>
                
                <button class="btn btn-secondary" onclick="mapEditor.debugUndoStack()" title="Show undo stack debug information">
                    üêõ Debug Undo
                </button>
                
                <button class="btn btn-warning" onclick="mapEditor.exportData()">
                    üíæ Export Data
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.importData()">
                    üì• Import Data
                </button>
            </div>
            
            <!-- Controls Guide -->
            <div class="panel-section">
                <div class="panel-title">üéÆ Controls</div>
                
                <div style="font-size: 12px; line-height: 1.6; color: #bdc3c7;">
                    <div style="margin-bottom: 8px;"><strong style="color: #3498db;">Navigation:</strong></div>
                    <div>‚Ä¢ <kbd>W A S D</kbd> - Pan around map</div>
                    <div>‚Ä¢ <kbd>Mouse Wheel</kbd> - Zoom in/out</div>
                    <div>‚Ä¢ <kbd>Left Click + Drag</kbd> - Pan view</div>
                    
                    <div style="margin: 12px 0 8px 0;"><strong style="color: #e74c3c;">Collision Editing:</strong></div>
                    <div>‚Ä¢ <kbd>Shift + A</kbd> - Add point at mouse</div>
                    <div>‚Ä¢ <kbd>Left Click</kbd> - Select/drag point</div>
                    <div>‚Ä¢ <kbd>Delete</kbd> - Remove selected point</div>
                    
                    <div style="margin: 12px 0 8px 0;"><strong style="color: #f39c12;">Actions:</strong></div>
                    <div>‚Ä¢ <kbd>Ctrl + Z</kbd> - Undo last action</div>
                    <div>‚Ä¢ <kbd>Esc</kbd> - Deselect point</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class StandaloneMapEditor {
            constructor() {
                this.canvas = document.getElementById('mapCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // World configuration (from game)
                this.WORLD_WIDTH = 10240;  // Game world width
                this.WORLD_HEIGHT = 7680;  // Game world height
                
                // Editor state
                this.zoom = 0.1;  // Start zoomed out to see full world
                this.minZoom = 0.05;
                this.maxZoom = 3.0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                
                // Display options
                this.showWorldBackground = true;
                this.showWorldBounds = true;
                this.showOceanWaves = false;  // Disabled by default for performance
                
                // Navigation state for WASD
                this.keys = {};
                this.panSpeed = 300; // pixels per second
                this.lastTime = performance.now();
                
                // Undo system
                this.undoStack = [];
                this.maxUndoSteps = 50;
                
                // Islands and collision data
                this.islands = [];
                this.selectedIsland = null;
                this.selectedPointIndex = -1;
                this.mousePos = { x: 0, y: 0 };
                this.worldMousePos = { x: 0, y: 0 };
                this.pointDragStarted = false;
                
                // Drawing settings
                this.pointRadius = 6;
                this.selectedPointRadius = 8;
                this.hoverPointIndex = -1;
                
                // Collision line drawing mode
                this.collisionLineMode = false;
                this.tempCollisionPoints = [];
                
                // Island manipulation
                this.ctrlPressed = false;
                this.islandDragStart = null;
                this.islandResizeMode = false;
                this.islandRotateMode = false;
                this.resizeStartDimensions = null;
                this.resizeStartMouse = null;
                this.rotateStartAngle = 0;
                this.rotateStartRotation = 0;
                this.rotateCenter = null;
                
                // Server status
                this.serverAvailable = false;
                
                this.init();
            }
            
            isNearIslandEdge(worldPos, island) {
                if (!island) return false;
                
                const edgeThreshold = 50; // pixels threshold for edge detection
                const left = island.x - island.width / 2;
                const right = island.x + island.width / 2;
                const top = island.y - island.height / 2;
                const bottom = island.y + island.height / 2;
                
                // Check if point is within island bounds but near edges
                const isInBounds = worldPos.x >= left && worldPos.x <= right && 
                                   worldPos.y >= top && worldPos.y <= bottom;
                
                if (!isInBounds) return false;
                
                // Check distance to edges
                const distToLeft = Math.abs(worldPos.x - left);
                const distToRight = Math.abs(worldPos.x - right);
                const distToTop = Math.abs(worldPos.y - top);
                const distToBottom = Math.abs(worldPos.y - bottom);
                
                return distToLeft < edgeThreshold || distToRight < edgeThreshold ||
                       distToTop < edgeThreshold || distToBottom < edgeThreshold;
            }
            
            setupEventHandlers() {
                // Handle island name dropdown changes
                const islandNameDropdown = document.getElementById('islandName');
                const newIslandNameInput = document.getElementById('newIslandName');
                
                islandNameDropdown.addEventListener('change', (e) => {
                    if (e.target.value === '__new__') {
                        newIslandNameInput.style.display = 'block';
                        newIslandNameInput.focus();
                    } else {
                        newIslandNameInput.style.display = 'none';
                        // Auto-fill position if selecting existing island
                        const existingIsland = this.islands.find(island => island.name === e.target.value);
                        if (existingIsland) {
                            document.getElementById('islandX').value = existingIsland.x;
                            document.getElementById('islandY').value = existingIsland.y;
                            document.getElementById('islandRadius').value = existingIsland.radius || 150;
                        }
                    }
                });
            }
            
            init() {
                this.setupEventListeners();
                this.setupCanvas();
                this.setupEventHandlers();
                this.loadExistingGameData();
                // Save initial state after loading data for proper undo functionality
                this.saveInitialUndoState();
                this.updateUndoButton(); // Initialize undo button state
                this.checkServerStatus();
                this.updateStatus('Map Editor Ready', 'info');
                this.startAnimationLoop();
                console.log('üó∫Ô∏è Standalone Map Editor initialized');
            }
            
            async checkServerStatus() {
                try {
                    const response = await fetch('http://localhost:8001/api/list-island-images', {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    if (response.ok) {
                        this.serverAvailable = true;
                        console.log('‚úÖ Image upload server available');
                    } else {
                        this.serverAvailable = false;
                        console.warn('‚ö†Ô∏è Image upload server responding but with errors');
                    }
                } catch (error) {
                    this.serverAvailable = false;
                    console.warn('‚ö†Ô∏è Image upload server not available. Images will not be saved to assets folder.');
                    console.log('üí° To enable image saving, run: npm run dev');
                }
            }
            
            loadExistingGameData() {
                // Load existing islands from the game project (exact game coordinates)
                const gameIslands = [
                    {
                        name: 'Saint Kitts Island',
                        x: 2000,    // Game world X coordinate
                        y: 1500,    // Game world Y coordinate
                        width: 800,
                        height: 600,
                        radius: 600, // Collision radius from game
                        rotation: 0, // Default rotation
                        image: null, // Will be loaded if available
                        originalImageData: null,
                        isExisting: true,  // Mark as existing game island
                        collision: [
                            { x: 1798.8, y: 968.6 },  // 2000 + (-201.2), 1500 + (-531.4)
                            { x: 1898.5, y: 1010.2 }, // 2000 + (-101.5), 1500 + (-489.8)
                            { x: 2015.5, y: 1159.5 }, // 2000 + (15.5), 1500 + (-340.5)
                            { x: 2128.0, y: 1241.3 }, // 2000 + (128.0), 1500 + (-258.7)
                            { x: 2212.3, y: 1405.1 }, // 2000 + (212.3), 1500 + (-94.9)
                            { x: 2223.6, y: 1496.4 }, // 2000 + (223.6), 1500 + (-3.6)
                            { x: 2273.3, y: 1700.0 }, // 2000 + (273.3), 1500 + (200.0)
                            { x: 2415.6, y: 1885.6 }, // 2000 + (415.6), 1500 + (385.6)
                            { x: 2498.0, y: 1895.8 }, // 2000 + (498.0), 1500 + (395.8)
                            { x: 2513.7, y: 1983.8 }, // 2000 + (513.7), 1500 + (483.8)
                            { x: 2455.2, y: 2032.7 }, // 2000 + (455.2), 1500 + (532.7)
                            { x: 2302.1, y: 2072.8 }, // 2000 + (302.1), 1500 + (572.8)
                            { x: 2280.7, y: 1979.3 }, // 2000 + (280.7), 1500 + (479.3)
                            { x: 2347.0, y: 1942.9 }, // 2000 + (347.0), 1500 + (442.9)
                            { x: 2282.8, y: 1793.8 }, // 2000 + (282.8), 1500 + (293.8)
                            { x: 2211.3, y: 1720.7 }, // 2000 + (211.3), 1500 + (220.7)
                            { x: 2152.4, y: 1700.6 }, // 2000 + (152.4), 1500 + (200.6)
                            { x: 2073.4, y: 1624.3 }, // 2000 + (73.4), 1500 + (124.3)
                            { x: 1997.1, y: 1613.6 }, // 2000 + (-2.9), 1500 + (113.6)
                            { x: 1825.0, y: 1572.1 }, // 2000 + (-175.0), 1500 + (72.1)
                            { x: 1612.4, y: 1383.1 }, // 2000 + (-387.6), 1500 + (-116.9)
                            { x: 1538.3, y: 1277.9 }, // 2000 + (-461.7), 1500 + (-222.1)
                            { x: 1553.8, y: 1203.5 }, // 2000 + (-446.2), 1500 + (-296.5)
                            { x: 1525.1, y: 1147.9 }, // 2000 + (-474.9), 1500 + (-352.1)
                            { x: 1477.7, y: 1078.4 }, // 2000 + (-522.3), 1500 + (-421.6)
                            { x: 1529.3, y: 1002.5 }, // 2000 + (-470.7), 1500 + (-497.5)
                            { x: 1654.5, y: 937.0 },  // 2000 + (-345.5), 1500 + (-563.0)
                            { x: 1768.6, y: 926.2 }   // 2000 + (-231.4), 1500 + (-573.8)
                        ]
                    },
                    {
                        name: 'Nevis',
                        x: 2699,    // Game world X coordinate
                        y: 2493,    // Game world Y coordinate
                        width: 2325,
                        height: 2324,
                        radius: 600, // Collision radius from game
                        rotation: 0, // Default rotation
                        image: null, // Will be loaded if available
                        originalImageData: null,
                        isExisting: true,  // Mark as existing game island
                        collision: [] // No collision points defined yet
                    }
                ];
                
                // Try to load island images automatically
                this.loadSaintKittsImage(gameIslands[0]);
                this.loadNevisImage(gameIslands[1]);
                
                // Convert game data to editor format
                this.islands = gameIslands;
                this.updateIslandSelector();
                
                if (this.islands.length > 0) {
                    this.selectIslandByIndex(0);
                    this.updateStatus(`Loaded ${this.islands.length} existing island(s) from game world: ${this.islands.map(i => i.name).join(', ')}`, 'success');
                    
                    // Start with a view of the entire world
                    this.resetToWorldView();
                }
                
                this.render();
            }
            
            loadSaintKittsImage(island) {
                // Try to load the Saint Kitts image from the project
                const img = new Image();
                img.onload = () => {
                    island.image = img;
                    island.imagePath = 'assets/Islands/Saint_Kitts.png';
                    this.updateStatus('Saint Kitts image loaded successfully', 'success');
                    this.render();
                };
                img.onerror = () => {
                    console.log('Could not load Saint Kitts image - using placeholder');
                    this.updateStatus('Using placeholder for Saint Kitts (image not found)', 'info');
                };
                img.src = 'assets/Islands/Saint_Kitts.png'; // Try to load from project
            }
            
            loadNevisImage(island) {
                // Try to load the Nevis image from the project
                const img = new Image();
                img.onload = () => {
                    island.image = img;
                    island.imagePath = 'assets/Islands/Nevis.png';
                    this.updateStatus('Nevis image loaded successfully', 'success');
                    this.render();
                };
                img.onerror = () => {
                    console.log('Could not load Nevis image - using placeholder');
                    this.updateStatus('Using placeholder for Nevis (image not found)', 'info');
                };
                img.src = 'assets/Islands/Nevis.png'; // Try to load from project
            }
            
            loadIslandImageFromPath(island, imagePath) {
                if (!imagePath && !island.originalImageData) return;
                
                const img = new Image();
                img.onload = () => {
                    island.image = img;
                    if (imagePath) island.imagePath = imagePath;
                    this.render();
                };
                img.onerror = () => {
                    console.warn(`Could not load image from path: ${imagePath}`);
                    // Fallback to originalImageData if path fails
                    if (island.originalImageData) {
                        console.log('Falling back to originalImageData for island:', island.name);
                        this.loadIslandFromBase64(island, island.originalImageData);
                    }
                };
                
                // Try to load from path first, fallback to originalImageData if no path
                if (imagePath) {
                    img.src = imagePath;
                } else if (island.originalImageData) {
                    img.src = island.originalImageData;
                }
            }
            
            loadIslandFromBase64(island, base64Data) {
                if (!base64Data) return;
                
                const img = new Image();
                img.onload = () => {
                    island.image = img;
                    this.render();
                };
                img.onerror = () => {
                    console.error('Failed to load image from base64 data for island:', island.name);
                };
                img.src = base64Data;
            }
            
            // Helper method to create a clean copy of islands data for serialization
            getSerializableIslands() {
                return this.islands.map(island => {
                    const cleanIsland = { ...island };
                    // Remove non-serializable properties like Image objects
                    delete cleanIsland.image;
                    return cleanIsland;
                });
            }
            
            centerOnIsland(island) {
                // Center the view on the specified island
                this.offsetX = -island.x * this.zoom + this.canvas.width / 2;
                this.offsetY = -island.y * this.zoom + this.canvas.height / 2;
            }
            
            setupCanvas() {
                // Set canvas size - much bigger for better navigation
                this.canvas.width = 1600;
                this.canvas.height = 1000;
                
                // Center the view on the game world
                this.offsetX = this.canvas.width / 2 - (this.WORLD_WIDTH * this.zoom) / 2;
                this.offsetY = this.canvas.height / 2 - (this.WORLD_HEIGHT * this.zoom) / 2;
                
                this.render();
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Keyboard events
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // Prevent default actions for navigation keys
                window.addEventListener('keydown', (e) => {
                    if (['KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                        e.preventDefault();
                    }
                });
                
                // Image input
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.handleImageLoad(e);
                });
                
                // Window resize
                window.addEventListener('resize', () => this.handleResize());
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mousePos.x = e.clientX - rect.left;
                this.mousePos.y = e.clientY - rect.top;
                this.updateWorldMousePos();
                
                if (e.button === 0) { // Left click
                    if (this.ctrlPressed) {
                        // Ctrl+Click - select island or manipulate selected island
                        const clickedIsland = this.getIslandAtPosition(this.worldMousePos);
                        
                        if (clickedIsland) {
                            // If we clicked on a different island, select it
                            if (clickedIsland !== this.selectedIsland) {
                                const islandIndex = this.islands.indexOf(clickedIsland);
                                this.selectIslandByIndex(islandIndex);
                                this.updateStatus(`Island "${clickedIsland.name}" selected - Ctrl+Click again to manipulate`, 'info');
                                this.render();
                                return;
                            }
                            
                            // We clicked on the already selected island - start manipulation
                            const islandClicked = this.isPointInIsland(this.worldMousePos, this.selectedIsland);
                            if (islandClicked) {
                            // Determine manipulation mode based on click position
                            const island = this.selectedIsland;
                            const dx = this.worldMousePos.x - island.x;
                            const dy = this.worldMousePos.y - island.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            // Check if clicking near edges for resize mode
                            const isNearEdge = this.isNearIslandEdge(this.worldMousePos, island);
                            
                            if (isNearEdge) {
                                // Start resize mode
                                this.islandResizeMode = true;
                                this.resizeStartDimensions = {
                                    width: island.width,
                                    height: island.height
                                };
                                this.resizeStartMouse = { ...this.worldMousePos };
                                this.updateStatus('CTRL+Click Resize Mode: Drag to resize island', 'info');
                            } else if (e.shiftKey) {
                                // CTRL+SHIFT+Click for rotation mode
                                this.islandRotateMode = true;
                                this.rotateStartAngle = Math.atan2(dy, dx);
                                this.rotateStartRotation = island.rotation || 0;
                                this.rotateCenter = { x: island.x, y: island.y };
                                this.updateStatus('CTRL+SHIFT+Click Rotate Mode: Drag to rotate island', 'info');
                            } else {
                                // Default: move mode
                                this.islandDragStart = {
                                    x: this.worldMousePos.x - island.x,
                                    y: this.worldMousePos.y - island.y
                                };
                                this.updateStatus('CTRL+Click Move Mode: Drag to move island', 'info');
                            }
                            
                            this.isDragging = true;
                            this.saveUndoState();
                            }
                        }
                    } else if (this.collisionLineMode && this.selectedIsland) {
                        // Add point in collision line mode
                        this.tempCollisionPoints.push({
                            x: this.worldMousePos.x,
                            y: this.worldMousePos.y
                        });
                        this.render();
                    } else if (this.selectedIsland) {
                        // Check if clicking on a collision point
                        const pointIndex = this.getPointAtMouse();
                        if (pointIndex !== -1) {
                            this.selectedPointIndex = pointIndex;
                            this.isDragging = true;
                        } else {
                            // Start panning
                            this.isDragging = true;
                            this.dragStart.x = this.mousePos.x;
                            this.dragStart.y = this.mousePos.y;
                        }
                    } else {
                        // Start panning
                        this.isDragging = true;
                        this.dragStart.x = this.mousePos.x;
                        this.dragStart.y = this.mousePos.y;
                    }
                } else if (e.button === 2) { // Right click
                    if (this.collisionLineMode) {
                        // Finish collision line
                        this.finishCollisionLine();
                    } else {
                        // Panning
                        this.isDragging = true;
                        this.dragStart.x = this.mousePos.x;
                        this.dragStart.y = this.mousePos.y;
                    }
                }
                
                this.render();
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mousePos.x = e.clientX - rect.left;
                this.mousePos.y = e.clientY - rect.top;
                this.updateWorldMousePos();
                
                // Update coordinates display
                document.getElementById('coordinatesDisplay').textContent = 
                    `Mouse: (${this.mousePos.x}, ${this.mousePos.y}) | World: (${this.worldMousePos.x.toFixed(1)}, ${this.worldMousePos.y.toFixed(1)})`;
                
                if (this.isDragging) {
                    if (this.islandResizeMode && this.selectedIsland) {
                        // Resize island
                        const mouseDx = this.worldMousePos.x - this.resizeStartMouse.x;
                        const mouseDy = this.worldMousePos.y - this.resizeStartMouse.y;
                        
                        // Apply resize based on mouse movement
                        const scaleFactor = 1 + (mouseDx + mouseDy) / 1000; // Adjust sensitivity
                        this.selectedIsland.width = Math.max(100, this.resizeStartDimensions.width * scaleFactor);
                        this.selectedIsland.height = Math.max(100, this.resizeStartDimensions.height * scaleFactor);
                        
                        // Update form controls
                        document.getElementById('islandWidth').value = Math.round(this.selectedIsland.width);
                        document.getElementById('islandHeight').value = Math.round(this.selectedIsland.height);
                    } else if (this.islandRotateMode && this.selectedIsland) {
                        // Rotate island
                        const dx = this.worldMousePos.x - this.rotateCenter.x;
                        const dy = this.worldMousePos.y - this.rotateCenter.y;
                        const currentAngle = Math.atan2(dy, dx);
                        const angleDiff = currentAngle - this.rotateStartAngle;
                        
                        // Convert to degrees and apply
                        const rotationDegrees = (angleDiff * 180 / Math.PI);
                        this.selectedIsland.rotation = (this.rotateStartRotation + rotationDegrees) % 360;
                        if (this.selectedIsland.rotation < 0) this.selectedIsland.rotation += 360;
                        
                        // Update form controls
                        document.getElementById('islandRotation').value = Math.round(this.selectedIsland.rotation);
                        document.getElementById('islandRotationValue').value = Math.round(this.selectedIsland.rotation);
                    } else if (this.islandDragStart && this.selectedIsland) {
                        // Drag entire island
                        this.selectedIsland.x = this.worldMousePos.x - this.islandDragStart.x;
                        this.selectedIsland.y = this.worldMousePos.y - this.islandDragStart.y;
                        this.updateIslandFormValues();
                    } else if (this.selectedPointIndex !== -1 && this.selectedIsland) {
                        // Drag collision point
                        if (!this.pointDragStarted) {
                            this.saveUndoState();
                            this.pointDragStarted = true;
                        }
                        
                        this.selectedIsland.collision[this.selectedPointIndex] = {
                            x: this.worldMousePos.x,
                            y: this.worldMousePos.y
                        };
                        this.updateCollisionPointsList();
                    } else {
                        // Pan view
                        const dx = this.mousePos.x - this.dragStart.x;
                        const dy = this.mousePos.y - this.dragStart.y;
                        this.offsetX += dx;
                        this.offsetY += dy;
                        this.dragStart.x = this.mousePos.x;
                        this.dragStart.y = this.mousePos.y;
                    }
                    this.render();
                }
                
                // Update hover state
                if (this.selectedIsland) {
                    this.hoverPointIndex = this.getPointAtMouse();
                    this.render();
                }
            }
            
            handleMouseUp(e) {
                this.isDragging = false;
                this.selectedPointIndex = -1;
                this.pointDragStarted = false;
                this.islandDragStart = null;
                
                // Reset manipulation modes
                if (this.islandResizeMode) {
                    this.islandResizeMode = false;
                    this.resizeStartDimensions = null;
                    this.resizeStartMouse = null;
                    this.updateStatus('Resize complete', 'success');
                }
                
                if (this.islandRotateMode) {
                    this.islandRotateMode = false;
                    this.rotateStartAngle = 0;
                    this.rotateStartRotation = 0;
                    this.rotateCenter = null;
                    this.updateStatus('Rotation complete', 'success');
                }
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom * zoomFactor));
                
                // Zoom towards mouse position
                const mouseWorldX = (this.mousePos.x - this.offsetX) / this.zoom;
                const mouseWorldY = (this.mousePos.y - this.offsetY) / this.zoom;
                
                this.zoom = newZoom;
                
                this.offsetX = this.mousePos.x - mouseWorldX * this.zoom;
                this.offsetY = this.mousePos.y - mouseWorldY * this.zoom;
                
                this.render();
            }
            
            handleKeyDown(e) {
                // Don't handle Ctrl+Z if an input element is focused (except for specific inputs that should allow it)
                const activeElement = document.activeElement;
                const isInputFocused = activeElement && (
                    activeElement.tagName === 'INPUT' || 
                    activeElement.tagName === 'TEXTAREA' || 
                    activeElement.tagName === 'SELECT'
                );
                
                // Handle Ctrl+Z carefully
                if (e.ctrlKey && e.code === 'KeyZ') {
                    // Allow undo unless user is typing in a text field
                    if (isInputFocused && activeElement.type === 'text') {
                        // Let the input handle its own undo
                        return;
                    }
                    
                    e.preventDefault();
                    
                    // Add safety check before undo
                    if (this.islands.length === 0 && this.undoStack.length > 0) {
                        console.warn('Preventing undo: islands array is empty but undo stack exists');
                        this.recoverFromUndoFailure();
                        return;
                    }
                    
                    this.undo();
                    return;
                }
                
                // Don't handle other keys if an input element is focused
                if (isInputFocused) {
                    return;
                }
                
                // Store key state for WASD navigation
                this.keys[e.code] = true;
                
                // Track Ctrl key
                if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                    this.ctrlPressed = true;
                    this.canvas.style.cursor = this.selectedIsland ? 'move' : 'crosshair';
                }
                
                // Handle special key combinations
                if (e.shiftKey && e.code === 'KeyA') {
                    // Shift+A: Add collision point at mouse position
                    e.preventDefault();
                    this.addCollisionPointAtMouse();
                    return;
                }
                
                if (e.code === 'Escape') {
                    // Esc: Cancel operations
                    e.preventDefault();
                    if (this.collisionLineMode) {
                        this.cancelCollisionLine();
                    } else {
                        this.selectedPointIndex = -1;
                        this.updateCollisionPointsList();
                        this.render();
                    }
                    return;
                }
                
                if (e.code === 'Delete' && this.selectedPointIndex !== -1 && this.selectedIsland) {
                    // Delete selected collision point
                    this.saveUndoState();
                    this.selectedIsland.collision.splice(this.selectedPointIndex, 1);
                    this.selectedPointIndex = -1;
                    this.updateCollisionPointsList();
                    this.render();
                }
            }
            
            handleKeyUp(e) {
                // Clear key state for WASD navigation
                this.keys[e.code] = false;
                
                // Track Ctrl key release
                if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                    this.ctrlPressed = false;
                    this.canvas.style.cursor = 'crosshair';
                }
            }
            
            updateWorldMousePos() {
                this.worldMousePos.x = (this.mousePos.x - this.offsetX) / this.zoom;
                this.worldMousePos.y = (this.mousePos.y - this.offsetY) / this.zoom;
            }
            
            getPointAtMouse() {
                if (!this.selectedIsland || !this.selectedIsland.collision) return -1;
                
                for (let i = 0; i < this.selectedIsland.collision.length; i++) {
                    const point = this.selectedIsland.collision[i];
                    const screenX = point.x * this.zoom + this.offsetX;
                    const screenY = point.y * this.zoom + this.offsetY;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.mousePos.x - screenX, 2) + 
                        Math.pow(this.mousePos.y - screenY, 2)
                    );
                    
                    if (distance <= this.pointRadius + 5) {
                        return i;
                    }
                }
                
                return -1;
            }
            
            addCollisionPointAtMouse() {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                if (!this.selectedIsland.collision) {
                    this.selectedIsland.collision = [];
                }
                
                // Save state for undo
                this.saveUndoState();
                
                this.selectedIsland.collision.push({
                    x: this.worldMousePos.x,
                    y: this.worldMousePos.y
                });
                
                this.updateCollisionPointsList();
                
                // Convert to relative coordinates for display
                const relativeX = this.worldMousePos.x - this.selectedIsland.x;
                const relativeY = this.worldMousePos.y - this.selectedIsland.y;
                this.updateStatus(`Added collision point at relative (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`, 'success');
            }
            
            handleImageLoad(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // Get island name from dropdown or prompt for new name
                        const islandNameDropdown = document.getElementById('islandName');
                        const newIslandNameInput = document.getElementById('newIslandName');
                        
                        let islandName;
                        let existingIsland = null;
                        
                        // Always prompt for island name when uploading image
                        const defaultName = islandNameDropdown.value === '__new__' ? 
                                          file.name.split('.')[0] : 
                                          islandNameDropdown.value;
                                          
                        islandName = prompt('Enter name for the island:', defaultName);
                        
                        // If user cancelled the prompt, use default name
                        if (!islandName || islandName.trim() === '') {
                            islandName = defaultName;
                        }
                        
                        islandName = islandName.trim();
                        
                        // Check if this island name already exists
                        existingIsland = this.islands.find(island => island.name === islandName);
                        
                        const x = parseFloat(document.getElementById('islandX').value) || 0;
                        const y = parseFloat(document.getElementById('islandY').value) || 0;
                        const radius = parseFloat(document.getElementById('islandRadius').value) || 150;
                        
                        // Save image to assets/Islands folder
                        this.saveImageToAssets(file, islandName, event.target.result)
                            .then(savedPath => {
                                if (existingIsland) {
                                    // Update existing island with new image
                                    existingIsland.image = img;
                                    existingIsland.originalImageData = event.target.result;
                                    existingIsland.imagePath = savedPath;
                                    existingIsland.width = img.width || existingIsland.width || 800;
                                    existingIsland.height = img.height || existingIsland.height || 600;
                                    
                                    // Select the updated island
                                    const islandIndex = this.islands.indexOf(existingIsland);
                                    this.selectIslandByIndex(islandIndex);
                                    this.updateStatus(`Updated and saved image for island: ${islandName}`, 'success');
                                } else {
                                    // Create new island
                                    const island = {
                                        name: islandName,
                                        x: x,
                                        y: y,
                                        width: img.width || 800,
                                        height: img.height || 600,
                                        radius: radius,
                                        rotation: parseFloat(document.getElementById('islandRotation').value) || 0,
                                        image: img,
                                        originalImageData: event.target.result,
                                        imagePath: savedPath,
                                        collision: []
                                    };
                                    
                                    this.islands.push(island);
                                    this.selectIslandByIndex(this.islands.length - 1);
                                    this.updateStatus(`Created new island: ${islandName} and saved image`, 'success');
                                }
                                
                                // Update dropdowns to reflect the chosen island name
                                this.updateIslandSelector();
                                
                                // Update the island name dropdown to show the selected/created island
                                if (islandNameDropdown.value !== islandName) {
                                    // Check if the name exists in dropdown, if not it was a new island
                                    const optionExists = [...islandNameDropdown.options].some(opt => opt.value === islandName);
                                    if (optionExists) {
                                        islandNameDropdown.value = islandName;
                                        newIslandNameInput.style.display = 'none';
                                    } else {
                                        islandNameDropdown.value = '__new__';
                                        newIslandNameInput.value = islandName;
                                        newIslandNameInput.style.display = 'block';
                                    }
                                }
                                
                                this.render();
                            })
                            .catch(error => {
                                console.error('Failed to save image:', error);
                                // Still create/update island even if save fails
                                if (existingIsland) {
                                    existingIsland.image = img;
                                    existingIsland.originalImageData = event.target.result;
                                    existingIsland.width = img.width || existingIsland.width || 800;
                                    existingIsland.height = img.height || existingIsland.height || 600;
                                    
                                    const islandIndex = this.islands.indexOf(existingIsland);
                                    this.selectIslandByIndex(islandIndex);
                                    this.updateStatus(`Updated island: ${islandName} (save failed)`, 'warning');
                                } else {
                                    const island = {
                                        name: islandName,
                                        x: x,
                                        y: y,
                                        width: img.width || 800,
                                        height: img.height || 600,
                                        radius: radius,
                                        rotation: parseFloat(document.getElementById('islandRotation').value) || 0,
                                        image: img,
                                        originalImageData: event.target.result,
                                        collision: []
                                    };
                                    
                                    this.islands.push(island);
                                    this.selectIslandByIndex(this.islands.length - 1);
                                    this.updateStatus(`Created island: ${islandName} (save failed)`, 'warning');
                                }
                                
                                // Update dropdowns to reflect the chosen island name
                                this.updateIslandSelector();
                                
                                // Update the island name dropdown to show the selected/created island
                                if (islandNameDropdown.value !== islandName) {
                                    // Check if the name exists in dropdown, if not it was a new island
                                    const optionExists = [...islandNameDropdown.options].some(opt => opt.value === islandName);
                                    if (optionExists) {
                                        islandNameDropdown.value = islandName;
                                        newIslandNameInput.style.display = 'none';
                                    } else {
                                        islandNameDropdown.value = '__new__';
                                        newIslandNameInput.value = islandName;
                                        newIslandNameInput.style.display = 'block';
                                    }
                                }
                                
                                this.render();
                            });
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            async saveImageToAssets(file, islandName, imageData) {
                try {
                    // Generate filename
                    const extension = file.name.split('.').pop() || 'png';
                    const cleanName = islandName.replace(/[^a-zA-Z0-9_-]/g, '_');
                    const filename = `${cleanName}.${extension}`;
                    
                    // Prepare data for server
                    const requestData = {
                        filename: filename,
                        imageData: imageData,
                        islandName: islandName
                    };
                    
                    const response = await fetch('http://localhost:8001/api/save-island-image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Server responded with ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('Image saved successfully:', result);
                    return result.path;
                    
                } catch (error) {
                    if (error.message.includes('Failed to fetch')) {
                        console.warn('Image upload server not running. Run "npm run dev" to enable image saving.');
                        throw new Error('Image upload server not running. Start it with "npm run dev" to save images to assets folder.');
                    } else {
                        console.error('Error saving image to assets:', error);
                        throw error;
                    }
                }
            }
            
            addIsland() {
                const islandNameDropdown = document.getElementById('islandName');
                const newIslandNameInput = document.getElementById('newIslandName');
                
                let name;
                if (islandNameDropdown.value === '__new__') {
                    name = newIslandNameInput.value.trim() || 'New Island';
                } else {
                    name = islandNameDropdown.value || 'New Island';
                }
                const x = parseFloat(document.getElementById('islandX').value) || 0;
                const y = parseFloat(document.getElementById('islandY').value) || 0;
                const radius = parseFloat(document.getElementById('islandRadius').value) || 150;
                
                const width = parseFloat(document.getElementById('islandWidth').value) || 800;
                const height = parseFloat(document.getElementById('islandHeight').value) || 600;
                
                const island = {
                    name: name,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    radius: radius,
                    rotation: parseFloat(document.getElementById('islandRotation').value) || 0,
                    image: null,
                    originalImageData: null,
                    collision: []
                };
                
                this.islands.push(island);
                this.updateIslandSelector();
                this.selectIslandByIndex(this.islands.length - 1);
                this.updateStatus(`Added island: ${name}`, 'success');
                this.render();
            }
            
            selectIsland() {
                const selector = document.getElementById('islandSelector');
                const index = parseInt(selector.value);
                
                if (index >= 0 && index < this.islands.length) {
                    this.selectIslandByIndex(index);
                } else {
                    this.selectedIsland = null;
                    this.updateCollisionPointsList();
                }
                
                this.render();
            }
            
            selectIslandByIndex(index) {
                this.selectedIsland = this.islands[index];
                this.selectedPointIndex = -1;
                
                // Update form values
                const islandNameDropdown = document.getElementById('islandName');
                const newIslandNameInput = document.getElementById('newIslandName');
                
                // Set dropdown to selected island name and hide new name input
                islandNameDropdown.value = this.selectedIsland.name;
                newIslandNameInput.style.display = 'none';
                document.getElementById('islandX').value = this.selectedIsland.x;
                document.getElementById('islandY').value = this.selectedIsland.y;
                document.getElementById('islandWidth').value = this.selectedIsland.width || 800;
                document.getElementById('islandHeight').value = this.selectedIsland.height || 600;
                document.getElementById('islandRadius').value = this.selectedIsland.radius;
                document.getElementById('islandRotation').value = this.selectedIsland.rotation || 0;
                document.getElementById('islandRotationValue').value = this.selectedIsland.rotation || 0;
                
                // Show/hide download button
                const downloadBtn = document.getElementById('downloadImageBtn');
                downloadBtn.style.display = this.selectedIsland.originalImageData ? 'block' : 'none';
                
                // Show/hide save island button
                const saveIslandBtn = document.getElementById('saveIslandBtn');
                saveIslandBtn.style.display = 'block'; // Always show when island is selected
                
                this.updateCollisionPointsList();
                this.updateStatus(`Selected island: ${this.selectedIsland.name}`, 'info');
            }
            
            updateIslandSelector() {
                const selector = document.getElementById('islandSelector');
                selector.innerHTML = '<option value="">-- Select Island --</option>';
                
                this.islands.forEach((island, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${island.name} (${island.x}, ${island.y})`;
                    selector.appendChild(option);
                });
                
                // Also update the island name dropdown
                this.updateIslandNameDropdown();
            }
            
            updateIslandNameDropdown() {
                const dropdown = document.getElementById('islandName');
                const currentValue = dropdown.value;
                
                // Clear existing options except "Add New Island"
                dropdown.innerHTML = '<option value="__new__">+ Add New Island</option>';
                
                // Add existing islands
                this.islands.forEach(island => {
                    const option = document.createElement('option');
                    option.value = island.name;
                    option.textContent = island.name;
                    dropdown.appendChild(option);
                });
                
                // Restore selection if it still exists
                if ([...dropdown.options].some(opt => opt.value === currentValue)) {
                    dropdown.value = currentValue;
                } else if (this.islands.length > 0) {
                    dropdown.value = this.islands[0].name;
                }
            }
            
            updateCollisionPointsList() {
                const list = document.getElementById('collisionPointsList');
                
                if (!this.selectedIsland || !this.selectedIsland.collision || this.selectedIsland.collision.length === 0) {
                    list.innerHTML = '<div style="text-align: center; color: #7f8c8d; font-style: italic;">No collision points</div>';
                    return;
                }
                
                list.innerHTML = '';
                this.selectedIsland.collision.forEach((point, index) => {
                    const div = document.createElement('div');
                    div.className = `collision-point ${index === this.selectedPointIndex ? 'selected' : ''}`;
                    
                    // Show both world and relative coordinates
                    const relativeX = point.x - this.selectedIsland.x;
                    const relativeY = point.y - this.selectedIsland.y;
                    
                    div.innerHTML = `
                        <div>${index + 1}: World (${point.x.toFixed(1)}, ${point.y.toFixed(1)})</div>
                        <div style="font-size: 10px; color: #bdc3c7;">Relative (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})</div>
                    `;
                    
                    div.onclick = () => {
                        this.selectedPointIndex = index;
                        this.updateCollisionPointsList();
                        this.render();
                    };
                    list.appendChild(div);
                });
            }
            
            addCollisionPoint() {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                // Save state for undo
                this.saveUndoState();
                
                // Add point at center of view
                const centerX = (-this.offsetX + this.canvas.width / 2) / this.zoom;
                const centerY = (-this.offsetY + this.canvas.height / 2) / this.zoom;
                
                if (!this.selectedIsland.collision) {
                    this.selectedIsland.collision = [];
                }
                
                this.selectedIsland.collision.push({ x: centerX, y: centerY });
                this.updateCollisionPointsList();
                this.updateStatus('Added collision point at center', 'success');
                this.render();
            }
            
            optimizePoints() {
                if (!this.selectedIsland || !this.selectedIsland.collision) {
                    this.updateStatus('No collision points to optimize', 'warning');
                    return;
                }
                
                // Save state for undo
                this.saveUndoState();
                
                const threshold = 10; // Minimum distance between points
                const original = this.selectedIsland.collision.length;
                
                for (let i = this.selectedIsland.collision.length - 1; i > 0; i--) {
                    const point1 = this.selectedIsland.collision[i];
                    const point2 = this.selectedIsland.collision[i - 1];
                    
                    const distance = Math.sqrt(
                        Math.pow(point1.x - point2.x, 2) + 
                        Math.pow(point1.y - point2.y, 2)
                    );
                    
                    if (distance < threshold) {
                        this.selectedIsland.collision.splice(i, 1);
                    }
                }
                
                const removed = original - this.selectedIsland.collision.length;
                this.updateCollisionPointsList();
                this.updateStatus(`Basic optimize: removed ${removed} redundant points`, 'success');
                this.render();
            }
            
            advancedOptimizePoints() {
                if (!this.selectedIsland || !this.selectedIsland.collision) {
                    this.updateStatus('No collision points to optimize', 'warning');
                    return;
                }
                
                if (this.selectedIsland.collision.length < 4) {
                    this.updateStatus('Need at least 4 points for advanced optimization', 'warning');
                    return;
                }
                
                // Show optimization options dialog
                const options = this.showOptimizationDialog();
                if (!options) return;
                
                // Save state for undo
                this.saveUndoState();
                
                const original = this.selectedIsland.collision.length;
                let optimizedPoints = [...this.selectedIsland.collision];
                
                // Apply selected optimization algorithms
                if (options.removeRedundant) {
                    optimizedPoints = this.removeRedundantPoints(optimizedPoints, options.threshold);
                }
                
                if (options.smoothPath) {
                    optimizedPoints = this.smoothCollisionPath(optimizedPoints, options.smoothFactor);
                }
                
                if (options.douglasPeucker) {
                    optimizedPoints = this.douglasPeuckerSimplify(optimizedPoints, options.dpTolerance);
                }
                
                if (options.removeCollinear) {
                    optimizedPoints = this.removeCollinearPoints(optimizedPoints, options.angleThreshold);
                }
                
                if (options.evenSpacing) {
                    optimizedPoints = this.createEvenSpacing(optimizedPoints, options.targetPoints);
                }
                
                // Ensure minimum number of points
                if (optimizedPoints.length < 3) {
                    this.updateStatus('Optimization would result in too few points', 'warning');
                    return;
                }
                
                this.selectedIsland.collision = optimizedPoints;
                const removed = original - optimizedPoints.length;
                
                this.updateCollisionPointsList();
                this.updateStatus(`Advanced optimize: ${original} ‚Üí ${optimizedPoints.length} points (${removed} removed)`, 'success');
                this.render();
            }
            
            showOptimizationDialog() {
                const dialog = `
Advanced Collision Optimization Options:

Choose optimization methods:
1. Remove redundant points (close neighbors)
2. Smooth collision path (reduce sharp angles)
3. Douglas-Peucker simplification (preserve shape)
4. Remove collinear points (straight line segments)
5. Create even spacing (redistribute points)

Enter numbers (e.g., "1,3,5" or "all" for all options):`;
                
                const input = prompt(dialog, "1,3");
                if (!input) return null;
                
                const selectedOptions = input.toLowerCase() === 'all' ? [1,2,3,4,5] : 
                    input.split(',').map(n => parseInt(n.trim())).filter(n => n >= 1 && n <= 5);
                
                if (selectedOptions.length === 0) {
                    this.updateStatus('No valid options selected', 'warning');
                    return null;
                }
                
                // Get parameters based on selected options
                const options = {
                    removeRedundant: selectedOptions.includes(1),
                    smoothPath: selectedOptions.includes(2),
                    douglasPeucker: selectedOptions.includes(3),
                    removeCollinear: selectedOptions.includes(4),
                    evenSpacing: selectedOptions.includes(5),
                    threshold: 15, // Distance threshold for redundant points
                    smoothFactor: 0.1, // Smoothing strength
                    dpTolerance: 5, // Douglas-Peucker tolerance
                    angleThreshold: 5, // Degrees for collinear detection
                    targetPoints: Math.max(8, Math.floor(this.selectedIsland.collision.length * 0.7)) // Target point count
                };
                
                return options;
            }
            
            removeRedundantPoints(points, threshold) {
                const result = [points[0]]; // Always keep first point
                
                for (let i = 1; i < points.length; i++) {
                    const current = points[i];
                    const last = result[result.length - 1];
                    
                    const distance = Math.sqrt(
                        Math.pow(current.x - last.x, 2) + 
                        Math.pow(current.y - last.y, 2)
                    );
                    
                    if (distance >= threshold) {
                        result.push(current);
                    }
                }
                
                return result;
            }
            
            smoothCollisionPath(points, smoothFactor) {
                if (points.length < 3) return points;
                
                const smoothed = [];
                
                for (let i = 0; i < points.length; i++) {
                    const prev = points[(i - 1 + points.length) % points.length];
                    const current = points[i];
                    const next = points[(i + 1) % points.length];
                    
                    // Calculate smoothed position
                    const smoothX = current.x + (prev.x + next.x - 2 * current.x) * smoothFactor;
                    const smoothY = current.y + (prev.y + next.y - 2 * current.y) * smoothFactor;
                    
                    smoothed.push({ x: smoothX, y: smoothY });
                }
                
                return smoothed;
            }
            
            douglasPeuckerSimplify(points, tolerance) {
                if (points.length < 3) return points;
                
                // Implementation of Douglas-Peucker algorithm
                const simplify = (pts, first, last, tol) => {
                    if (last - first < 2) return [];
                    
                    let maxDist = 0;
                    let maxIndex = 0;
                    
                    // Find point with maximum distance from line segment
                    for (let i = first + 1; i < last; i++) {
                        const dist = this.pointToLineDistance(pts[i], pts[first], pts[last]);
                        if (dist > maxDist) {
                            maxDist = dist;
                            maxIndex = i;
                        }
                    }
                    
                    if (maxDist > tol) {
                        // Recursively simplify segments
                        const left = simplify(pts, first, maxIndex, tol);
                        const right = simplify(pts, maxIndex, last, tol);
                        return left.concat([pts[maxIndex]], right);
                    } else {
                        return [];
                    }
                };
                
                const simplified = [points[0]].concat(
                    simplify(points, 0, points.length - 1, tolerance),
                    [points[points.length - 1]]
                );
                
                return simplified;
            }
            
            removeCollinearPoints(points, angleThreshold) {
                if (points.length < 3) return points;
                
                const result = [];
                const radThreshold = (angleThreshold * Math.PI) / 180;
                
                for (let i = 0; i < points.length; i++) {
                    const prev = points[(i - 1 + points.length) % points.length];
                    const current = points[i];
                    const next = points[(i + 1) % points.length];
                    
                    // Calculate angle between vectors
                    const v1 = { x: current.x - prev.x, y: current.y - prev.y };
                    const v2 = { x: next.x - current.x, y: next.y - current.y };
                    
                    const angle = Math.abs(Math.atan2(v1.x * v2.y - v1.y * v2.x, v1.x * v2.x + v1.y * v2.y));
                    
                    // Keep point if angle is significant
                    if (angle > radThreshold && angle < Math.PI - radThreshold) {
                        result.push(current);
                    }
                }
                
                return result.length >= 3 ? result : points; // Fallback if too few points
            }
            
            createEvenSpacing(points, targetCount) {
                if (points.length <= targetCount) return points;
                
                // Calculate total perimeter
                let totalLength = 0;
                for (let i = 0; i < points.length; i++) {
                    const current = points[i];
                    const next = points[(i + 1) % points.length];
                    totalLength += Math.sqrt(
                        Math.pow(next.x - current.x, 2) + 
                        Math.pow(next.y - current.y, 2)
                    );
                }
                
                const segmentLength = totalLength / targetCount;
                const result = [];
                
                let currentLength = 0;
                let targetLength = 0;
                
                for (let i = 0; i < points.length && result.length < targetCount; i++) {
                    const current = points[i];
                    const next = points[(i + 1) % points.length];
                    
                    const segLength = Math.sqrt(
                        Math.pow(next.x - current.x, 2) + 
                        Math.pow(next.y - current.y, 2)
                    );
                    
                    while (currentLength + segLength >= targetLength && result.length < targetCount) {
                        const t = (targetLength - currentLength) / segLength;
                        const interpolated = {
                            x: current.x + t * (next.x - current.x),
                            y: current.y + t * (next.y - current.y)
                        };
                        
                        result.push(interpolated);
                        targetLength += segmentLength;
                    }
                    
                    currentLength += segLength;
                }
                
                return result;
            }
            
            pointToLineDistance(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                const param = dot / lenSq;
                
                let xx, yy;
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            clearCollision() {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                if (confirm(`Clear all collision points for ${this.selectedIsland.name}?`)) {
                    // Save state for undo
                    this.saveUndoState();
                    
                    this.selectedIsland.collision = [];
                    this.selectedPointIndex = -1;
                    this.updateCollisionPointsList();
                    this.updateStatus('Collision points cleared', 'success');
                    this.render();
                }
            }
            
            saveIslandConfiguration() {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                const island = this.selectedIsland;
                
                // Generate comprehensive island configuration
                const config = {
                    // Basic Information
                    name: island.name,
                    
                    // Position and Dimensions
                    position: {
                        x: Math.round(island.x),
                        y: Math.round(island.y)
                    },
                    
                    dimensions: {
                        width: Math.round(island.width || 800),
                        height: Math.round(island.height || 600),
                        radius: Math.round(island.radius || 150)
                    },
                    
                    // Transformation
                    rotation: Math.round(island.rotation || 0),
                    
                    // Image Information
                    image: {
                        path: island.imagePath || null,
                        hasImage: !!island.image,
                        hasOriginalData: !!island.originalImageData
                    },
                    
                    // Collision Data
                    collision: {
                        pointCount: island.collision ? island.collision.length : 0,
                        points: island.collision ? island.collision.map(point => ({
                            // World coordinates
                            world: {
                                x: Math.round(point.x * 10) / 10,
                                y: Math.round(point.y * 10) / 10
                            },
                            // Relative to island center
                            relative: {
                                x: Math.round((point.x - island.x) * 10) / 10,
                                y: Math.round((point.y - island.y) * 10) / 10
                            }
                        })) : []
                    },
                    
                    // Metadata
                    metadata: {
                        isExisting: island.isExisting || false,
                        generated: new Date().toISOString(),
                        editorVersion: '1.0.0'
                    }
                };
                
                // Generate code output for Agent integration
                const codeOutput = this.generateAgentIntegrationCode(config);
                
                // Show in modal dialog
                this.showIslandConfigurationDialog(config, codeOutput);
                
                // Also copy to clipboard
                try {
                    navigator.clipboard.writeText(codeOutput).then(() => {
                        this.updateStatus('Island configuration copied to clipboard', 'success');
                    });
                } catch (error) {
                    console.warn('Could not copy to clipboard:', error);
                    this.updateStatus('Island configuration generated (clipboard not available)', 'success');
                }
            }
            
            generateAgentIntegrationCode(config) {
                const island = config;
                
                let code = `// ===== ISLAND CONFIGURATION FOR AGENT INTEGRATION =====\n\n`;
                code += `// Island: ${island.name}\n`;
                code += `// Generated: ${island.metadata.generated}\n\n`;
                
                // JavaScript object format
                code += `const ${island.name.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase()}Config = {\n`;
                code += `    name: "${island.name}",\n`;
                code += `    position: { x: ${island.position.x}, y: ${island.position.y} },\n`;
                code += `    dimensions: { width: ${island.dimensions.width}, height: ${island.dimensions.height}, radius: ${island.dimensions.radius} },\n`;
                code += `    rotation: ${island.rotation},\n`;
                
                if (island.image.path) {
                    code += `    imagePath: "${island.image.path}",\n`;
                }
                
                if (island.collision.pointCount > 0) {
                    code += `    collision: [\n`;
                    island.collision.points.forEach((point, index) => {
                        const comma = index < island.collision.points.length - 1 ? ',' : '';
                        code += `        { x: ${point.relative.x}, y: ${point.relative.y} }${comma}  // World: (${point.world.x}, ${point.world.y})\n`;
                    });
                    code += `    ]\n`;
                } else {
                    code += `    collision: []  // No collision points defined\n`;
                }
                
                code += `};\n\n`;
                
                // Usage examples
                code += `// ===== USAGE EXAMPLES =====\n\n`;
                code += `// 1. Add to game map configuration:\n`;
                code += `// gameMap.addIsland(${island.name.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase()}Config);\n\n`;
                
                code += `// 2. Agent integration format:\n`;
                code += `/*\n`;
                code += `ISLAND_DATA:\n`;
                code += `Name: ${island.name}\n`;
                code += `Position: (${island.position.x}, ${island.position.y})\n`;
                code += `Dimensions: ${island.dimensions.width}x${island.dimensions.height}px\n`;
                code += `Collision Radius: ${island.dimensions.radius}px\n`;
                code += `Rotation: ${island.rotation}¬∞\n`;
                code += `Collision Points: ${island.collision.pointCount}\n`;
                if (island.image.path) {
                    code += `Image: ${island.image.path}\n`;
                }
                code += `*/\n\n`;
                
                code += `// 3. JSON format for API/config files:\n`;
                code += JSON.stringify(island, null, 2);
                
                return code;
            }
            
            showIslandConfigurationDialog(config, codeOutput) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    font-family: monospace;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: #2c3e50;
                    color: #ecf0f1;
                    padding: 20px;
                    border-radius: 8px;
                    max-width: 90%;
                    max-height: 90%;
                    overflow: auto;
                    border: 2px solid #3498db;
                `;
                
                dialog.innerHTML = `
                    <h2 style="color: #3498db; margin-top: 0;">üèùÔ∏è Island Configuration: ${config.name}</h2>
                    <div style="margin-bottom: 15px;">
                        <strong>üìç Position:</strong> (${config.position.x}, ${config.position.y})<br>
                        <strong>üìê Dimensions:</strong> ${config.dimensions.width}√ó${config.dimensions.height}px<br>
                        <strong>üîÑ Rotation:</strong> ${config.rotation}¬∞<br>
                        <strong>üí• Collision Points:</strong> ${config.collision.pointCount}<br>
                        <strong>üñºÔ∏è Image:</strong> ${config.image.hasImage ? '‚úÖ Loaded' : '‚ùå No image'}<br>
                    </div>
                    <textarea readonly style="
                        width: 100%;
                        height: 400px;
                        background: #34495e;
                        color: #ecf0f1;
                        border: 1px solid #3498db;
                        border-radius: 4px;
                        padding: 10px;
                        font-family: 'Courier New', monospace;
                        font-size: 12px;
                        resize: vertical;
                    ">${codeOutput}</textarea>
                    <div style="margin-top: 15px; text-align: center;">
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                            background: #3498db;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 4px;
                            cursor: pointer;
                            margin-right: 10px;
                        ">‚úÖ Close</button>
                        <button onclick="
                            const textarea = this.parentElement.parentElement.querySelector('textarea');
                            textarea.select();
                            document.execCommand('copy');
                            this.textContent = 'üìã Copied!';
                            setTimeout(() => this.textContent = 'üìã Copy Code', 1000);
                        " style="
                            background: #27ae60;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 4px;
                            cursor: pointer;
                        ">üìã Copy Code</button>
                    </div>
                `;
                
                modal.appendChild(dialog);
                document.body.appendChild(modal);
                
                // Close on escape key
                const closeHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeHandler);
                    }
                };
                document.addEventListener('keydown', closeHandler);
                
                // Auto-select the textarea content
                setTimeout(() => {
                    const textarea = dialog.querySelector('textarea');
                    textarea.focus();
                    textarea.select();
                }, 100);
            }
            
            async propagateToProject() {
                if (!this.selectedIsland || !this.selectedIsland.collision || this.selectedIsland.collision.length === 0) {
                    this.updateStatus('No collision data to propagate', 'warning');
                    return;
                }
                
                try {
                    this.updateStatus('Propagating to project...', 'info');
                    this.setProgress(20);
                    
                    // Generate collision code
                    const collisionCode = this.generateCollisionCode();
                    this.setProgress(50);
                    
                    // Copy to clipboard
                    await navigator.clipboard.writeText(collisionCode);
                    this.setProgress(80);
                    
                    // Show success message
                    this.setProgress(100);
                    this.updateStatus('‚úÖ Code copied to clipboard! Paste into map.js', 'success');
                    
                    // Show integration instructions
                    this.showIntegrationDialog(collisionCode);
                    
                    setTimeout(() => {
                        this.setProgress(0);
                        this.updateStatus('Ready for editing', 'info');
                    }, 3000);
                    
                } catch (error) {
                    console.error('Propagation error:', error);
                    this.updateStatus('‚ùå Failed to propagate to project', 'warning');
                    this.setProgress(0);
                }
            }
            
            generateCollisionCode() {
                const island = this.selectedIsland;
                const points = island.collision;
                
                // Convert world coordinates back to relative coordinates for the game
                const relativePoints = points.map(point => ({
                    x: point.x - island.x,
                    y: point.y - island.y
                }));
                
                let code = `generateCustomOutline(island) {\n`;
                code += `    // MANUAL COLLISION OUTLINE CONFIGURATION\n`;
                code += `    // ${island.name} - ${points.length} collision points (updated with map editor)\n\n`;
                code += `    // ${island.name} - ${points.length} collision points\n`;
                code += `    const saintKittsIslandPoints = [\n`;
                
                relativePoints.forEach((point, index) => {
                    const comma = index < relativePoints.length - 1 ? ',' : '';
                    code += `        { x: ${point.x.toFixed(1)}, y: ${point.y.toFixed(1)} }${comma}\n`;
                });
                
                code += `    ];\n\n`;
                code += `    // Usage in generateCustomOutline():\n`;
                code += `    return {\n`;
                code += `        points: saintKittsIslandPoints,\n`;
                code += `        bounds: this.calculateOutlineBounds(saintKittsIslandPoints)\n`;
                code += `    };\n`;
                code += `}`;
                
                return code;
            }
            
            showIntegrationDialog(code) {
                const relativePoints = this.selectedIsland.collision.map(point => ({
                    x: point.x - this.selectedIsland.x,
                    y: point.y - this.selectedIsland.y
                }));
                
                const dialog = `
INTEGRATION COMPLETE! üöÄ

‚úÖ Collision code copied to clipboard
‚úÖ Island: ${this.selectedIsland.name}
‚úÖ Position: (${this.selectedIsland.x}, ${this.selectedIsland.y})
‚úÖ Points: ${this.selectedIsland.collision.length} collision points
‚úÖ Coordinates: Converted to relative positions

NEXT STEPS:
1. Open js/map.js in your editor
2. Find the generateCustomOutline() method (around line 125)
3. Replace it with the clipboard code
4. Save and refresh your game

The collision points are automatically converted to the correct 
relative coordinates for your project!
                `;
                
                alert(dialog);
            }
            
            updateStatus(message, type = 'info') {
                const indicator = document.getElementById('statusIndicator');
                if (indicator) {
                    indicator.textContent = message;
                    indicator.className = `status-indicator status-${type}`;
                    
                    if (type === 'success') {
                        indicator.classList.add('pulsing');
                        setTimeout(() => indicator.classList.remove('pulsing'), 2000);
                    }
                } else {
                    // Fallback to console if status indicator doesn't exist
                    console.log(`Status: ${message} (${type})`);
                }
            }
            
            setProgress(percent) {
                const fill = document.getElementById('progressFill');
                if (fill) {
                    fill.style.width = percent + '%';
                }
            }
            
            zoomIn() {
                this.zoom = Math.min(this.maxZoom, this.zoom * 1.2);
                this.render();
            }
            
            zoomOut() {
                this.zoom = Math.max(this.minZoom, this.zoom * 0.8);
                this.render();
            }
            
            resetZoom() {
                this.zoom = 1.0;
                this.offsetX = -this.canvas.width / 2;
                this.offsetY = -this.canvas.height / 2;
                this.render();
            }
            
            resetToWorldView() {
                // Reset view to show the entire game world
                const worldAspect = this.WORLD_WIDTH / this.WORLD_HEIGHT;
                const canvasAspect = this.canvas.width / this.canvas.height;
                
                if (worldAspect > canvasAspect) {
                    // World is wider - fit to width
                    this.zoom = (this.canvas.width * 0.9) / this.WORLD_WIDTH;
                } else {
                    // World is taller - fit to height
                    this.zoom = (this.canvas.height * 0.9) / this.WORLD_HEIGHT;
                }
                
                // Center the world in the canvas
                this.offsetX = this.canvas.width / 2 - (this.WORLD_WIDTH * this.zoom) / 2;
                this.offsetY = this.canvas.height / 2 - (this.WORLD_HEIGHT * this.zoom) / 2;
                
                this.render();
            }
            
            resetView() {
                if (this.selectedIsland) {
                    // Center on selected island
                    this.offsetX = -this.selectedIsland.x * this.zoom + this.canvas.width / 2;
                    this.offsetY = -this.selectedIsland.y * this.zoom + this.canvas.height / 2;
                } else {
                    this.resetZoom();
                }
                this.render();
            }
            
            exportData() {
                const data = {
                    islands: this.islands.map(island => ({
                        name: island.name,
                        x: island.x,
                        y: island.y,
                        radius: island.radius,
                        collision: island.collision
                    }))
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'map-editor-data.json';
                a.click();
                
                URL.revokeObjectURL(url);
                this.updateStatus('Data exported successfully', 'success');
            }
            
            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            
                            if (data.islands) {
                                this.islands = data.islands.map(island => ({
                                    ...island,
                                    image: null // Images need to be reloaded
                                }));
                                
                                this.updateIslandSelector();
                                this.selectedIsland = null;
                                this.updateCollisionPointsList();
                                this.render();
                                this.updateStatus('Data imported successfully', 'success');
                            }
                        } catch (error) {
                            this.updateStatus('Failed to import data', 'warning');
                            console.error('Import error:', error);
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            }
            
            handleResize() {
                // Handle window resize
                const wrapper = document.querySelector('.canvas-wrapper');
                this.canvas.width = wrapper.clientWidth;
                this.canvas.height = wrapper.clientHeight;
                this.render();
            }
            
            startAnimationLoop() {
                // Start the animation loop for WASD navigation
                const animate = (currentTime) => {
                    const deltaTime = (currentTime - this.lastTime) / 1000;
                    this.lastTime = currentTime;
                    
                    this.updateNavigation(deltaTime);
                    requestAnimationFrame(animate);
                };
                
                requestAnimationFrame(animate);
            }
            
            updateNavigation(deltaTime) {
                let moved = false;
                const moveDistance = this.panSpeed * deltaTime;
                
                // WASD navigation
                if (this.keys['KeyW']) {
                    this.offsetY += moveDistance;
                    moved = true;
                }
                if (this.keys['KeyS']) {
                    this.offsetY -= moveDistance;
                    moved = true;
                }
                if (this.keys['KeyA']) {
                    this.offsetX += moveDistance;
                    moved = true;
                }
                if (this.keys['KeyD']) {
                    this.offsetX -= moveDistance;
                    moved = true;
                }
                
                if (moved) {
                    this.render();
                }
            }
            
            saveUndoState() {
                try {
                    // Don't save undo state if islands array is empty (unless it's intentionally empty after deletion)
                    if (this.islands.length === 0 && this.undoStack.length === 0) {
                        return;
                    }
                    
                    // Create a clean copy of the islands without Image objects
                    const cleanIslands = this.islands.map(island => {
                        const cleanIsland = {
                            name: island.name,
                            x: island.x,
                            y: island.y,
                            width: island.width,
                            height: island.height,
                            radius: island.radius,
                            rotation: island.rotation || 0,
                            collision: Array.isArray(island.collision) ? [...island.collision] : [],
                            isExisting: island.isExisting,
                            originalImageData: island.originalImageData,
                            imagePath: island.imagePath // Preserve image path for proper reloading
                        };
                        return cleanIsland;
                    });
                    
                    // Save current state for undo functionality
                    const state = {
                        islands: cleanIslands,
                        selectedIslandIndex: this.selectedIsland ? this.islands.indexOf(this.selectedIsland) : -1
                    };
                    
                    this.undoStack.push(state);
                    
                    // Limit undo stack size
                    if (this.undoStack.length > this.maxUndoSteps) {
                        this.undoStack.shift();
                    }
                    
                    this.updateUndoButton();
                    
                } catch (error) {
                    console.error('Failed to save undo state:', error);
                    this.updateStatus('Warning: Could not save undo state', 'warning');
                }
            }
            
            saveInitialUndoState() {
                // Save the initial state after loading game data
                if (this.islands.length > 0) {
                    // Create a clean copy of the islands without Image objects
                    const cleanIslands = this.islands.map(island => {
                        const cleanIsland = {
                            name: island.name,
                            x: island.x,
                            y: island.y,
                            width: island.width,
                            height: island.height,
                            radius: island.radius,
                            rotation: island.rotation || 0,
                            collision: Array.isArray(island.collision) ? [...island.collision] : [],
                            isExisting: island.isExisting,
                            originalImageData: island.originalImageData,
                            imagePath: island.imagePath // Preserve image path for proper reloading
                        };
                        return cleanIsland;
                    });
                    
                    const state = {
                        islands: cleanIslands,
                        selectedIslandIndex: this.selectedIsland ? this.islands.indexOf(this.selectedIsland) : -1
                    };
                    
                    this.undoStack.push(state);
                    console.log('Initial undo state saved with', this.islands.length, 'islands');
                }
            }
            
            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    // Disable if no undo actions available (need at least 2 states: initial + current)
                    const canUndo = this.undoStack.length > 1;
                    undoBtn.disabled = !canUndo;
                    
                    if (!canUndo) {
                        undoBtn.title = 'No actions to undo';
                    } else {
                        const availableUndos = this.undoStack.length - 1; // Subtract 1 for initial state
                        undoBtn.title = `Undo last action (${availableUndos} action${availableUndos !== 1 ? 's' : ''} available) - Ctrl+Z`;
                    }
                }
            }
            
            undo() {
                if (this.undoStack.length === 0) {
                    this.updateStatus('Nothing to undo', 'warning');
                    return;
                }
                
                // Don't allow undo if we only have the initial state
                if (this.undoStack.length === 1) {
                    this.updateStatus('Already at initial state', 'warning');
                    return;
                }
                
                try {
                    // Remove current state and get previous state
                    this.undoStack.pop(); // Remove current state
                    const state = this.undoStack[this.undoStack.length - 1]; // Get previous state (but keep it in stack)
                    
                    // Restore state
                    this.islands = state.islands.map(island => {
                        const restoredIsland = { ...island };
                        
                        // Reload images for all existing islands based on their name
                        if (island.isExisting) {
                            if (island.name === 'Saint Kitts Island') {
                                this.loadSaintKittsImage(restoredIsland);
                            } else if (island.name === 'Nevis') {
                                this.loadNevisImage(restoredIsland);
                            }
                        } else if (island.imagePath || island.originalImageData) {
                            // Load custom uploaded images
                            this.loadIslandImageFromPath(restoredIsland, island.imagePath);
                        }
                        
                        return restoredIsland;
                    });
                    
                    // Restore selected island
                    if (state.selectedIslandIndex >= 0 && state.selectedIslandIndex < this.islands.length) {
                        this.selectedIsland = this.islands[state.selectedIslandIndex];
                    } else {
                        this.selectedIsland = null;
                    }
                    
                    // Update UI
                    this.updateIslandSelector();
                    this.updateCollisionPointsList();
                    this.selectedPointIndex = -1;
                    this.updateUndoButton();
                    
                    this.updateStatus(`Undo completed (${this.undoStack.length - 1} more available)`, 'success');
                    this.render();
                    
                } catch (error) {
                    console.error('Undo operation failed:', error);
                    this.updateStatus('Undo failed: ' + error.message, 'warning');
                }
            }
            
            recoverFromUndoFailure() {
                console.log('Attempting to recover from undo failure...');
                
                // Clear corrupted undo stack
                this.undoStack = [];
                
                // Reload initial game data
                try {
                    this.loadExistingGameData();
                    this.updateStatus('Recovered from undo failure - data reloaded', 'info');
                } catch (error) {
                    console.error('Recovery failed:', error);
                    this.updateStatus('Recovery failed - please refresh the page', 'warning');
                }
            }
            
            debugUndoStack() {
                console.log('=== UNDO STACK DEBUG INFO ===');
                console.log('Current islands count:', this.islands.length);
                console.log('Undo stack length:', this.undoStack.length);
                console.log('Selected island:', this.selectedIsland ? this.selectedIsland.name : 'none');
                
                if (this.undoStack.length > 0) {
                    console.log('Undo stack contents:');
                    this.undoStack.forEach((state, index) => {
                        console.log(`  ${index}: ${state.islands?.length || 'invalid'} islands, selectedIndex: ${state.selectedIslandIndex}, timestamp: ${new Date(state.timestamp || 0).toLocaleTimeString()}`);
                    });
                } else {
                    console.log('Undo stack is empty');
                }
                
                // Validate current islands
                let validIslands = 0;
                for (let i = 0; i < this.islands.length; i++) {
                    const island = this.islands[i];
                    if (island && typeof island === 'object' && island.name && typeof island.x === 'number') {
                        validIslands++;
                    } else {
                        console.log(`  Invalid island at index ${i}:`, island);
                    }
                }
                
                const debugInfo = `Debug Info:
‚Ä¢ Current Islands: ${this.islands.length} (${validIslands} valid)
‚Ä¢ Undo Stack: ${this.undoStack.length} states
‚Ä¢ Selected: ${this.selectedIsland ? this.selectedIsland.name : 'none'}
‚Ä¢ Stack Status: ${this.undoStack.length > 1 ? 'Can undo' : 'Cannot undo'}

See console for detailed information.`;
                
                alert(debugInfo);
                this.updateStatus('Debug info logged to console', 'info');
            }
            
            render() {
                // Clear canvas with deep ocean color
                this.ctx.fillStyle = '#0a1a2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw world background
                if (this.showWorldBackground) {
                    this.drawWorldBackground();
                }
                
                // Draw world boundaries
                if (this.showWorldBounds) {
                    this.drawWorldBounds();
                }
                
                // Draw coordinate grid
                this.drawGrid();
                
                // Draw islands
                this.islands.forEach((island, index) => {
                    this.drawIsland(island, index === this.islands.indexOf(this.selectedIsland));
                });
                
                // Draw UI elements
                this.drawUI();
            }
            
            drawWorldBackground() {
                // Draw the game world ocean background
                const worldScreenX = this.offsetX;
                const worldScreenY = this.offsetY;
                const worldScreenWidth = this.WORLD_WIDTH * this.zoom;
                const worldScreenHeight = this.WORLD_HEIGHT * this.zoom;
                
                // Ocean gradient
                const gradient = this.ctx.createLinearGradient(
                    worldScreenX, worldScreenY,
                    worldScreenX + worldScreenWidth, worldScreenY + worldScreenHeight
                );
                gradient.addColorStop(0, '#1e3a5f');
                gradient.addColorStop(0.5, '#2c5f8a');
                gradient.addColorStop(1, '#1e3a5f');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(worldScreenX, worldScreenY, worldScreenWidth, worldScreenHeight);
                
                // Optional: Draw simplified wave pattern
                if (this.showOceanWaves) {
                    this.drawSimpleWaves();
                }
            }
            
            drawWorldBounds() {
                // Draw the game world boundaries
                const worldScreenX = this.offsetX;
                const worldScreenY = this.offsetY;
                const worldScreenWidth = this.WORLD_WIDTH * this.zoom;
                const worldScreenHeight = this.WORLD_HEIGHT * this.zoom;
                
                this.ctx.strokeStyle = '#3498db';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(worldScreenX, worldScreenY, worldScreenWidth, worldScreenHeight);
                
                // Draw corner markers
                const markerSize = 20;
                this.ctx.fillStyle = '#3498db';
                
                // Top-left
                this.ctx.fillRect(worldScreenX - 2, worldScreenY - 2, markerSize, 4);
                this.ctx.fillRect(worldScreenX - 2, worldScreenY - 2, 4, markerSize);
                
                // Top-right
                this.ctx.fillRect(worldScreenX + worldScreenWidth - markerSize + 2, worldScreenY - 2, markerSize, 4);
                this.ctx.fillRect(worldScreenX + worldScreenWidth - 2, worldScreenY - 2, 4, markerSize);
                
                // Bottom-left
                this.ctx.fillRect(worldScreenX - 2, worldScreenY + worldScreenHeight - 2, markerSize, 4);
                this.ctx.fillRect(worldScreenX - 2, worldScreenY + worldScreenHeight - markerSize + 2, 4, markerSize);
                
                // Bottom-right
                this.ctx.fillRect(worldScreenX + worldScreenWidth - markerSize + 2, worldScreenY + worldScreenHeight - 2, markerSize, 4);
                this.ctx.fillRect(worldScreenX + worldScreenWidth - 2, worldScreenY + worldScreenHeight - markerSize + 2, 4, markerSize);
                
                // Add world size label
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(
                    `Game World: ${this.WORLD_WIDTH}x${this.WORLD_HEIGHT}px`,
                    worldScreenX + worldScreenWidth / 2,
                    worldScreenY - 10
                );
            }
            
            drawSimpleWaves() {
                // Simple wave animation for visual effect
                const time = Date.now() * 0.001;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;
                
                const waveSpacing = 100 * this.zoom;
                const amplitude = 10 * this.zoom;
                
                for (let y = this.offsetY; y < this.offsetY + this.WORLD_HEIGHT * this.zoom; y += waveSpacing) {
                    this.ctx.beginPath();
                    for (let x = this.offsetX; x < this.offsetX + this.WORLD_WIDTH * this.zoom; x += 10) {
                        const waveY = y + Math.sin((x - this.offsetX) * 0.01 + time) * amplitude;
                        if (x === this.offsetX) {
                            this.ctx.moveTo(x, waveY);
                        } else {
                            this.ctx.lineTo(x, waveY);
                        }
                    }
                    this.ctx.stroke();
                }
            }
            
            drawGrid() {
                // Draw coordinate grid with world-based spacing
                const majorGridSize = 1000 * this.zoom;  // 1000px world units
                const minorGridSize = 500 * this.zoom;   // 500px world units
                
                // Only draw grid if it's visible enough
                if (majorGridSize < 10) return;
                
                // Calculate grid bounds based on world coordinates
                const worldLeft = -this.offsetX / this.zoom;
                const worldTop = -this.offsetY / this.zoom;
                const worldRight = (this.canvas.width - this.offsetX) / this.zoom;
                const worldBottom = (this.canvas.height - this.offsetY) / this.zoom;
                
                // Major grid lines
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                this.ctx.lineWidth = 1;
                
                // Vertical major lines
                for (let worldX = Math.floor(worldLeft / 1000) * 1000; worldX <= worldRight; worldX += 1000) {
                    const screenX = worldX * this.zoom + this.offsetX;
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenX, 0);
                    this.ctx.lineTo(screenX, this.canvas.height);
                    this.ctx.stroke();
                    
                    // Grid labels
                    if (this.zoom > 0.1) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        this.ctx.font = '12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(worldX.toString(), screenX, 20);
                    }
                }
                
                // Horizontal major lines
                for (let worldY = Math.floor(worldTop / 1000) * 1000; worldY <= worldBottom; worldY += 1000) {
                    const screenY = worldY * this.zoom + this.offsetY;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenY);
                    this.ctx.lineTo(this.canvas.width, screenY);
                    this.ctx.stroke();
                    
                    // Grid labels
                    if (this.zoom > 0.1) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        this.ctx.font = '12px Arial';
                        this.ctx.textAlign = 'left';
                        this.ctx.fillText(worldY.toString(), 5, screenY - 5);
                    }
                }
                
                // Minor grid lines (only when zoomed in enough)
                if (minorGridSize > 20) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                    this.ctx.lineWidth = 1;
                    
                    // Minor vertical lines
                    for (let worldX = Math.floor(worldLeft / 500) * 500; worldX <= worldRight; worldX += 500) {
                        if (worldX % 1000 !== 0) {  // Skip major grid lines
                            const screenX = worldX * this.zoom + this.offsetX;
                            this.ctx.beginPath();
                            this.ctx.moveTo(screenX, 0);
                            this.ctx.lineTo(screenX, this.canvas.height);
                            this.ctx.stroke();
                        }
                    }
                    
                    // Minor horizontal lines
                    for (let worldY = Math.floor(worldTop / 500) * 500; worldY <= worldBottom; worldY += 500) {
                        if (worldY % 1000 !== 0) {  // Skip major grid lines
                            const screenY = worldY * this.zoom + this.offsetY;
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, screenY);
                            this.ctx.lineTo(this.canvas.width, screenY);
                            this.ctx.stroke();
                        }
                    }
                }
            }
            
            drawIsland(island, isSelected) {
                const screenX = island.x * this.zoom + this.offsetX;
                const screenY = island.y * this.zoom + this.offsetY;
                const screenRadius = island.radius * this.zoom;
                
                // Use configured dimensions if available
                // Match the game's rendering - use radius * 2 for dimensions
                const width = island.radius * 2 * this.zoom;
                const height = island.radius * 2 * this.zoom;
                
                // Draw island image or placeholder with rotation
                this.ctx.save();
                this.ctx.translate(screenX, screenY);
                
                // Apply rotation if specified
                const rotation = island.rotation || 0;
                if (rotation !== 0) {
                    this.ctx.rotate((rotation * Math.PI) / 180);
                }
                
                if (island.image && island.image instanceof HTMLImageElement && island.image.complete) {
                    this.ctx.drawImage(
                        island.image,
                        -width / 2,
                        -height / 2,
                        width,
                        height
                    );
                    
                    // Draw dimension outline when selected
                    if (isSelected) {
                        this.ctx.strokeStyle = '#3498db';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(
                            -width / 2,
                            -height / 2,
                            width,
                            height
                        );
                    }
                } else {
                    // Draw placeholder rectangle
                    this.ctx.fillStyle = isSelected ? '#27ae60' : '#8fbc8f';
                    this.ctx.fillRect(
                        -width / 2,
                        -height / 2,
                        width,
                        height
                    );
                }
                
                this.ctx.restore();
                
                // Draw island collision radius outline
                this.ctx.strokeStyle = isSelected ? '#3498db' : '#2ecc71';
                this.ctx.lineWidth = isSelected ? 3 : 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw island name and info
                this.ctx.fillStyle = island.isExisting ? '#e74c3c' : '#ffffff';
                this.ctx.font = `${Math.max(12, 14 * this.zoom)}px Arial`;
                this.ctx.textAlign = 'center';
                const displayName = island.isExisting ? `${island.name} (EXISTING)` : island.name;
                const displayRotation = island.rotation || 0;
                const nameWithRotation = displayRotation !== 0 ? `${displayName} (${displayRotation}¬∞)` : displayName;
                this.ctx.fillText(nameWithRotation, screenX, screenY - height / 2 - 20);
                
                if (isSelected) {
                    this.ctx.font = `${Math.max(10, 12 * this.zoom)}px Arial`;
                    this.ctx.fillText(`${Math.round(island.width)}x${Math.round(island.height)}px`, screenX, screenY - height / 2 - 5);
                    
                    if (island.isExisting) {
                        this.ctx.fillStyle = '#f39c12';
                        this.ctx.fillText('Game World Island', screenX, screenY + height / 2 + 15);
                    }
                }
                
                // Draw collision points
                if (island.collision && island.collision.length > 0) {
                    this.drawCollisionOutline(island);
                }
            }
            
            drawCollisionOutline(island) {
                if (!island.collision || island.collision.length < 2) return;
                
                const isSelected = island === this.selectedIsland;
                
                // Draw collision outline
                this.ctx.strokeStyle = isSelected ? '#e74c3c' : '#f39c12';
                this.ctx.lineWidth = isSelected ? 2 : 1;
                this.ctx.beginPath();
                
                const firstPoint = island.collision[0];
                this.ctx.moveTo(
                    firstPoint.x * this.zoom + this.offsetX,
                    firstPoint.y * this.zoom + this.offsetY
                );
                
                for (let i = 1; i < island.collision.length; i++) {
                    const point = island.collision[i];
                    this.ctx.lineTo(
                        point.x * this.zoom + this.offsetX,
                        point.y * this.zoom + this.offsetY
                    );
                }
                
                this.ctx.closePath();
                this.ctx.stroke();
                
                // Draw collision points
                island.collision.forEach((point, index) => {
                    const screenX = point.x * this.zoom + this.offsetX;
                    const screenY = point.y * this.zoom + this.offsetY;
                    
                    let pointColor = '#3498db';
                    let radius = this.pointRadius;
                    
                    if (isSelected && index === this.selectedPointIndex) {
                        pointColor = '#e74c3c';
                        radius = this.selectedPointRadius;
                    } else if (isSelected && index === this.hoverPointIndex) {
                        pointColor = '#f39c12';
                        radius = this.selectedPointRadius;
                    }
                    
                    this.ctx.fillStyle = pointColor;
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw point index
                    if (isSelected && this.zoom > 0.5) {
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = '10px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText((index + 1).toString(), screenX, screenY + 3);
                    }
                });
            }
            
            drawUI() {
                // Draw zoom and world info
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(10, this.canvas.height - 80, 250, 70);
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Zoom: ${(this.zoom * 100).toFixed(1)}%`, 15, this.canvas.height - 60);
                this.ctx.fillText(`World: ${this.WORLD_WIDTH}x${this.WORLD_HEIGHT}px`, 15, this.canvas.height - 45);
                this.ctx.fillText(`Undo: ${this.undoStack.length}/${this.maxUndoSteps}`, 15, this.canvas.height - 30);
                
                // World coordinate at mouse position
                const worldX = (this.mousePos.x - this.offsetX) / this.zoom;
                const worldY = (this.mousePos.y - this.offsetY) / this.zoom;
                this.ctx.fillText(`World Pos: (${worldX.toFixed(0)}, ${worldY.toFixed(0)})`, 15, this.canvas.height - 15);
                
                // Draw server status indicator
                const serverStatus = this.serverAvailable ? 'üü¢ Server OK' : 'üî¥ Server OFF';
                const serverColor = this.serverAvailable ? '#27ae60' : '#e74c3c';
                this.ctx.fillStyle = serverColor;
                this.ctx.fillText(`Image Saving: ${serverStatus}`, 270, this.canvas.height - 15);
                
                // Draw collision line mode indicator
                if (this.collisionLineMode) {
                    this.ctx.fillStyle = 'rgba(231, 76, 60, 0.9)';
                    this.ctx.fillRect(200, this.canvas.height - 50, 200, 40);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('COLLISION LINE MODE', 300, this.canvas.height - 25);
                    
                    // Draw temp collision points
                    if (this.tempCollisionPoints.length > 0) {
                        this.drawTempCollisionLine();
                    }
                }
                
                // Draw manipulation mode indicators
                if (this.islandResizeMode) {
                    this.ctx.fillStyle = 'rgba(52, 152, 219, 0.9)';
                    this.ctx.fillRect(this.canvas.width - 220, this.canvas.height - 80, 200, 25);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('üîÑ RESIZE MODE', this.canvas.width - 120, this.canvas.height - 62);
                } else if (this.islandRotateMode) {
                    this.ctx.fillStyle = 'rgba(155, 89, 182, 0.9)';
                    this.ctx.fillRect(this.canvas.width - 220, this.canvas.height - 80, 200, 25);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('‚Üª ROTATE MODE', this.canvas.width - 120, this.canvas.height - 62);
                } else if (this.islandDragStart) {
                    this.ctx.fillStyle = 'rgba(46, 204, 113, 0.9)';
                    this.ctx.fillRect(this.canvas.width - 220, this.canvas.height - 80, 200, 25);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('‚úã MOVE MODE', this.canvas.width - 120, this.canvas.height - 62);
                }
                
                // Draw enhanced island editing instructions
                if (this.ctrlPressed || (this.collisionEditor && this.collisionEditor.selectedIsland)) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    this.ctx.fillRect(this.canvas.width - 320, 10, 310, 130);
                    this.ctx.fillStyle = '#f39c12';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText('üó∫Ô∏è Enhanced Island Editor', this.canvas.width - 315, 30);
                    
                    this.ctx.font = '12px Arial';
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillText('‚Ä¢ CTRL+Click: Select any island', this.canvas.width - 315, 50);
                    this.ctx.fillStyle = '#27ae60';
                    this.ctx.fillText('‚Ä¢ Green corners: Drag to resize', this.canvas.width - 315, 65);
                    this.ctx.fillStyle = '#9b59b6';
                    this.ctx.fillText('‚Ä¢ Purple diamond: Drag to rotate', this.canvas.width - 315, 80);
                    this.ctx.fillStyle = '#3498db';
                    this.ctx.fillText('‚Ä¢ Blue dots: Edit collision points', this.canvas.width - 315, 95);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillText('‚Ä¢ Right-click: Add collision point', this.canvas.width - 315, 110);
                    this.ctx.fillText('‚Ä¢ Del key: Delete selected point', this.canvas.width - 315, 125);
                }
            }
        
            // New methods for enhanced functionality
            toggleCollisionLineMode() {
                this.collisionLineMode = !this.collisionLineMode;
                this.tempCollisionPoints = [];
                
                const btn = document.getElementById('collisionLineModeBtn');
                if (this.collisionLineMode) {
                    btn.textContent = 'üî¥ Stop Drawing';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-danger');
                    this.updateStatus('Click to add points, right-click to finish', 'info');
                } else {
                    btn.textContent = '‚úèÔ∏è Draw Collision Line';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-primary');
                    this.updateStatus('Collision line mode disabled', 'info');
                }
                
                this.render();
            }
            
            finishCollisionLine() {
                if (this.tempCollisionPoints.length > 2) {
                    this.saveUndoState();
                    this.selectedIsland.collision = this.selectedIsland.collision.concat(this.tempCollisionPoints);
                    this.updateCollisionPointsList();
                    this.updateStatus(`Added ${this.tempCollisionPoints.length} collision points`, 'success');
                } else {
                    this.updateStatus('Need at least 3 points for collision line', 'warning');
                }
                
                this.tempCollisionPoints = [];
                this.toggleCollisionLineMode();
            }
            
            cancelCollisionLine() {
                this.tempCollisionPoints = [];
                this.collisionLineMode = false;
                const btn = document.getElementById('collisionLineModeBtn');
                btn.textContent = '‚úèÔ∏è Draw Collision Line';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-primary');
                this.updateStatus('Collision line cancelled', 'info');
                this.render();
            }
            
            drawTempCollisionLine() {
                if (this.tempCollisionPoints.length === 0) return;
                
                this.ctx.strokeStyle = '#e74c3c';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                
                const firstPoint = this.tempCollisionPoints[0];
                this.ctx.moveTo(
                    firstPoint.x * this.zoom + this.offsetX,
                    firstPoint.y * this.zoom + this.offsetY
                );
                
                for (let i = 1; i < this.tempCollisionPoints.length; i++) {
                    const point = this.tempCollisionPoints[i];
                    this.ctx.lineTo(
                        point.x * this.zoom + this.offsetX,
                        point.y * this.zoom + this.offsetY
                    );
                }
                
                // Draw line to mouse position
                this.ctx.lineTo(
                    this.worldMousePos.x * this.zoom + this.offsetX,
                    this.worldMousePos.y * this.zoom + this.offsetY
                );
                
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw temp points
                this.tempCollisionPoints.forEach(point => {
                    const screenX = point.x * this.zoom + this.offsetX;
                    const screenY = point.y * this.zoom + this.offsetY;
                    
                    this.ctx.fillStyle = '#e74c3c';
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            isPointInIsland(point, island) {
                const width = (island.width || 800) * 0.5;
                const height = (island.height || 600) * 0.5;
                
                return point.x >= island.x - width &&
                       point.x <= island.x + width &&
                       point.y >= island.y - height &&
                       point.y <= island.y + height;
            }
            
            getIslandAtPosition(point) {
                // Check islands in reverse order (top to bottom rendering)
                for (let i = this.islands.length - 1; i >= 0; i--) {
                    const island = this.islands[i];
                    if (this.isPointInIsland(point, island)) {
                        return island;
                    }
                }
                return null;
            }
            
            updateIslandFormValues() {
                if (!this.selectedIsland) return;
                
                document.getElementById('islandX').value = Math.round(this.selectedIsland.x);
                document.getElementById('islandY').value = Math.round(this.selectedIsland.y);
            }
            
            updateIslandProperty(property, value) {
                if (!this.selectedIsland) return;
                
                const numValue = parseFloat(value);
                if (isNaN(numValue)) return;
                
                this.selectedIsland[property] = numValue;
                this.render();
            }
            
            updateRotation(value) {
                // Update both slider and input field
                document.getElementById('islandRotation').value = value;
                document.getElementById('islandRotationValue').value = value;
                
                // Update selected island if exists
                if (this.selectedIsland) {
                    this.saveUndoState();
                    this.selectedIsland.rotation = parseFloat(value);
                    this.render();
                    this.updateStatus(`Island rotation set to ${value}¬∞`, 'info');
                }
            }
            
            rotateIsland(degrees) {
                if (!this.selectedIsland) return;
                
                this.saveUndoState();
                const currentRotation = this.selectedIsland.rotation || 0;
                const newRotation = (currentRotation + degrees) % 360;
                
                this.selectedIsland.rotation = newRotation < 0 ? newRotation + 360 : newRotation;
                
                // Update form controls
                document.getElementById('islandRotation').value = this.selectedIsland.rotation;
                document.getElementById('islandRotationValue').value = this.selectedIsland.rotation;
                
                this.render();
                this.updateStatus(`Island rotated by ${degrees}¬∞`, 'info');
            }
            
            resetImageDimensions() {
                if (!this.selectedIsland || !this.selectedIsland.image) return;
                
                this.saveUndoState();
                this.selectedIsland.width = this.selectedIsland.image.naturalWidth || this.selectedIsland.image.width;
                this.selectedIsland.height = this.selectedIsland.image.naturalHeight || this.selectedIsland.image.height;
                
                // Update form controls
                document.getElementById('islandWidth').value = this.selectedIsland.width;
                document.getElementById('islandHeight').value = this.selectedIsland.height;
                
                this.render();
                this.updateStatus('Island dimensions reset to original size', 'success');
            }
            
            rotateSelected(degrees) {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                this.saveUndoState();
                
                // Add rotation and normalize to 0-360 range
                let newRotation = (this.selectedIsland.rotation || 0) + degrees;
                newRotation = ((newRotation % 360) + 360) % 360; // Ensure positive value
                
                this.selectedIsland.rotation = newRotation;
                
                // Update form controls
                document.getElementById('islandRotation').value = newRotation;
                document.getElementById('islandRotationValue').value = newRotation;
                
                this.render();
                this.updateStatus(`Island rotated ${degrees > 0 ? 'clockwise' : 'counter-clockwise'} to ${newRotation}¬∞`, 'success');
            }
            
            downloadSelectedIslandImage() {
                if (!this.selectedIsland || !this.selectedIsland.originalImageData) {
                    this.updateStatus('No image to download', 'warning');
                    return;
                }
                
                // Create download link
                const link = document.createElement('a');
                link.href = this.selectedIsland.originalImageData;
                link.download = `${this.selectedIsland.name.replace(/\s+/g, '_')}.png`;
                link.click();
                
                this.updateStatus(`Downloaded ${this.selectedIsland.name} image`, 'success');
            }
            
            
            toggleWorldBackground() {
                this.showWorldBackground = !this.showWorldBackground;
                const btn = document.getElementById('worldBackgroundBtn');
                btn.textContent = this.showWorldBackground ? 'üåä Hide Ocean' : 'üåä Show Ocean';
                this.render();
            }
            
            toggleWorldBounds() {
                this.showWorldBounds = !this.showWorldBounds;
                const btn = document.getElementById('worldBoundsBtn');
                btn.textContent = this.showWorldBounds ? 'üìé Hide Boundaries' : 'üìé Show Boundaries';
                this.render();
            }
            
            toggleOceanWaves() {
                this.showOceanWaves = !this.showOceanWaves;
                const btn = document.getElementById('oceanWavesBtn');
                btn.textContent = this.showOceanWaves ? 'üåä Hide Waves' : 'üåä Show Waves';
                this.render();
            }
        }
        
        // Initialize the map editor
        let mapEditor;
        window.addEventListener('DOMContentLoaded', () => {
            mapEditor = new StandaloneMapEditor();
            window.mapEditor = mapEditor; // Make it globally accessible
        });
    </script>
    
    <!-- Include the collision editor for enhanced functionality -->
    <script src="js/collision-editor.js"></script>
    
    <script>
        // Integrate collision editor with standalone map editor
        window.addEventListener('DOMContentLoaded', () => {
            // Wait for the map editor to be fully initialized
            setTimeout(() => {
                if (window.mapEditor && window.MapEditor) {
                    const mapEditor = window.mapEditor;
                // Add the calculateOutlineBounds method to the map editor if it doesn't exist
                if (!mapEditor.calculateOutlineBounds) {
                    mapEditor.calculateOutlineBounds = function(points) {
                        let minX = Infinity, minY = Infinity;
                        let maxX = -Infinity, maxY = -Infinity;
                        
                        points.forEach(point => {
                            minX = Math.min(minX, point.x);
                            minY = Math.min(minY, point.y);
                            maxX = Math.max(maxX, point.x);
                            maxY = Math.max(maxY, point.y);
                        });
                        
                        return { minX, minY, maxX, maxY };
                    };
                }
                
                // Create a mock game object for the collision editor
                const mockGame = {
                    canvas: mapEditor.canvas,
                    zoom: mapEditor.zoom,
                    cameraX: -mapEditor.offsetX,
                    cameraY: -mapEditor.offsetY,
                    map: {
                        islands: mapEditor.islands,
                        calculateOutlineBounds: mapEditor.calculateOutlineBounds.bind(mapEditor)
                    }
                };
                
                // Initialize collision editor with mock game
                mapEditor.collisionEditor = new MapEditor(mockGame);
                mapEditor.collisionEditor.isActive = true; // Always active in standalone editor
                
                // Override some methods to work with standalone editor
                mapEditor.originalHandleMouseDown = mapEditor.handleMouseDown.bind(mapEditor);
                mapEditor.handleMouseDown = function(e) {
                    // Update mock game state
                    mockGame.zoom = this.zoom;
                    mockGame.cameraX = -this.offsetX;
                    mockGame.cameraY = -this.offsetY;
                    
                    // Try collision editor first
                    if (this.collisionEditor.handleMouseDown(e)) {
                        return;
                    }
                    
                    // Fall back to original handler
                    this.originalHandleMouseDown(e);
                };
                
                mapEditor.originalHandleMouseMove = mapEditor.handleMouseMove.bind(mapEditor);
                mapEditor.handleMouseMove = function(e) {
                    // Update mock game state
                    mockGame.zoom = this.zoom;
                    mockGame.cameraX = -this.offsetX;
                    mockGame.cameraY = -this.offsetY;
                    
                    // Try collision editor first
                    if (this.collisionEditor.handleMouseMove(e)) {
                        return;
                    }
                    
                    // Fall back to original handler
                    this.originalHandleMouseMove(e);
                };
                
                mapEditor.originalHandleMouseUp = mapEditor.handleMouseUp.bind(mapEditor);
                mapEditor.handleMouseUp = function(e) {
                    // Update mock game state
                    mockGame.zoom = this.zoom;
                    mockGame.cameraX = -this.offsetX;
                    mockGame.cameraY = -this.offsetY;
                    
                    // Try collision editor first
                    if (this.collisionEditor.handleMouseUp(e)) {
                        return;
                    }
                    
                    // Fall back to original handler
                    this.originalHandleMouseUp(e);
                };
                
                // Add collision editor overlay to render method
                mapEditor.originalRender = mapEditor.render.bind(mapEditor);
                mapEditor.render = function() {
                    this.originalRender();
                    
                    // Update mock game state
                    mockGame.zoom = this.zoom;
                    mockGame.cameraX = -this.offsetX;
                    mockGame.cameraY = -this.offsetY;
                    
                    // Draw collision editor overlay
                    this.collisionEditor.drawEditorOverlay(this.ctx);
                };
                
                console.log('üó∫Ô∏è Enhanced Map Editor loaded with island selection capabilities');
                console.log('üí° Ctrl+Click on islands to select them for editing');
                }
            }, 100); // Wait 100ms for mapEditor to initialize
        });
    </script>
</body>
</html>
