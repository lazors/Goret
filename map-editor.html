<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GORET - Standalone Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            overflow: hidden;
        }

        .editor-container {
            display: flex;
            height: 100vh;
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background: #0f1419;
        }

        #mapCanvas {
            display: block;
            cursor: crosshair;
            background: #1e3a5f;
        }

        .control-panel {
            width: 350px;
            background: rgba(30, 60, 95, 0.95);
            backdrop-filter: blur(10px);
            border-left: 2px solid #3498db;
            padding: 20px;
            overflow-y: auto;
        }

        .panel-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(52, 73, 94, 0.7);
            border-radius: 8px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .panel-title::before {
            content: "üó∫Ô∏è";
            margin-right: 8px;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(45deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        .btn-success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(45deg, #c0392b, #e74c3c);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        .btn-warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-warning:hover {
            background: linear-gradient(45deg, #e67e22, #f39c12);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #7f8c8d, #95a5a6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(149, 165, 166, 0.4);
        }

        .btn-secondary:disabled {
            background: linear-gradient(45deg, #bdc3c7, #95a5a6);
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .input-group {
            margin: 10px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #bdc3c7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 4px;
            background: rgba(44, 62, 80, 0.8);
            color: #ecf0f1;
            font-size: 14px;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.3);
        }

        .status-indicator {
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
            text-align: center;
            font-weight: bold;
        }

        .status-success {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            color: #2ecc71;
        }

        .status-info {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            color: #3498db;
        }

        .status-warning {
            background: rgba(243, 156, 18, 0.2);
            border: 1px solid #f39c12;
            color: #f39c12;
        }

        .collision-points-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(44, 62, 80, 0.5);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .collision-point {
            padding: 5px 8px;
            margin: 2px 0;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border-left: 3px solid #3498db;
        }

        .collision-point.selected {
            background: rgba(231, 76, 60, 0.2);
            border-left-color: #e74c3c;
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 350px;
            background: rgba(30, 60, 95, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-bottom: 2px solid #3498db;
            z-index: 1000;
        }

        .header h1 {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
            margin: 0;
        }

        .header .subtitle {
            font-size: 12px;
            color: #bdc3c7;
            margin-top: 5px;
        }

        .canvas-wrapper {
            margin-top: 80px;
            height: calc(100vh - 80px);
            overflow: auto;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .zoom-btn:hover {
            background: rgba(52, 152, 219, 1);
            transform: scale(1.1);
        }

        .coordinates-display {
            position: absolute;
            top: 90px;
            left: 20px;
            background: rgba(44, 62, 80, 0.9);
            padding: 10px 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .file-input {
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(44, 62, 80, 0.5);
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .pulsing {
            animation: pulse 1.5s infinite;
        }
        
        kbd {
            background: rgba(44, 62, 80, 0.8);
            border: 1px solid rgba(52, 152, 219, 0.3);
            border-radius: 3px;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #3498db;
            margin: 0 2px;
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="canvas-area">
            <div class="header">
                <h1>üó∫Ô∏è GORET Map Editor</h1>
                <div class="subtitle">Standalone Map & Collision Editor - Direct Project Integration</div>
            </div>
            
            <div class="coordinates-display" id="coordinatesDisplay">
                Mouse: (0, 0) | World: (0, 0)
            </div>
            
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="mapEditor.zoomIn()">+</button>
                <button class="zoom-btn" onclick="mapEditor.zoomOut()">-</button>
                <button class="zoom-btn" onclick="mapEditor.resetZoom()">‚åÇ</button>
            </div>
            
            <div class="canvas-wrapper">
                <canvas id="mapCanvas" width="1600" height="1000"></canvas>
            </div>
        </div>
        
        <div class="control-panel">
            <!-- Island Management -->
            <div class="panel-section">
                <div class="panel-title">Island Management</div>
                
                <input type="file" id="imageInput" class="file-input" accept="image/*">
                <button class="btn btn-primary" onclick="document.getElementById('imageInput').click()">
                    üìÅ Load Island Image
                </button>
                
                <div class="input-group">
                    <label>Island Name</label>
                    <input type="text" id="islandName" placeholder="Enter island name" value="Saint Kitts">
                </div>
                
                <div class="input-group">
                    <label>Position X</label>
                    <input type="number" id="islandX" value="0">
                </div>
                
                <div class="input-group">
                    <label>Position Y</label>
                    <input type="number" id="islandY" value="0">
                </div>
                
                <div class="input-group">
                    <label>Width (pixels)</label>
                    <input type="number" id="islandWidth" value="800" min="100" max="2000">
                </div>
                
                <div class="input-group">
                    <label>Height (pixels)</label>
                    <input type="number" id="islandHeight" value="600" min="100" max="2000">
                </div>
                
                <div class="input-group">
                    <label>Radius (collision)</label>
                    <input type="number" id="islandRadius" value="150">
                </div>
                
                <button class="btn btn-success" onclick="mapEditor.addIsland()">
                    ‚ûï Add Island
                </button>
                
                <button class="btn btn-warning" onclick="mapEditor.downloadSelectedIslandImage()" id="downloadImageBtn" style="display: none;">
                    üíæ Download Island Image
                </button>
                
                <button class="btn btn-secondary" onclick="mapEditor.undo()" id="undoBtn" title="Undo last action (Ctrl+Z)">
                    ‚Ü∂ Undo
                </button>
            </div>
            
            <!-- Collision Editing -->
            <div class="panel-section">
                <div class="panel-title">Collision Editor</div>
                
                <div class="input-group">
                    <label>Select Island</label>
                    <select id="islandSelector" onchange="mapEditor.selectIsland()">
                        <option value="">-- Select Island --</option>
                    </select>
                </div>
                
                <button class="btn btn-primary" onclick="mapEditor.addCollisionPoint()">
                    üìç Add Point
                </button>
                
                <button class="btn btn-warning" onclick="mapEditor.optimizePoints()">
                    ‚ö° Optimize
                </button>
                
                <button class="btn btn-danger" onclick="mapEditor.clearCollision()">
                    üóëÔ∏è Clear Points
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.toggleCollisionLineMode()" id="collisionLineModeBtn">
                    ‚úèÔ∏è Draw Collision Line
                </button>
                
                <div class="collision-points-list" id="collisionPointsList">
                    <div style="text-align: center; color: #7f8c8d; font-style: italic;">
                        Select an island to edit collision points
                    </div>
                </div>
            </div>
            
            <!-- Project Integration -->
            <div class="panel-section">
                <div class="panel-title">Project Integration</div>
                
                <button class="btn btn-success" onclick="mapEditor.generateCodeWithPrompt()" id="generateCodeBtn">
                    üìã Generate Code & Prompt
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.copyImageInstructions()">
                    üìÅ Copy Image Install Instructions
                </button>
                
                <div class="status-indicator status-info" id="statusIndicator">
                    Ready for editing
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <!-- World Display -->
            <div class="panel-section">
                <div class="panel-title">üåç World Display</div>
                
                <button class="btn btn-primary" onclick="mapEditor.resetToWorldView()">
                    üåç Show Full World
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.toggleWorldBackground()" id="worldBackgroundBtn">
                    üåä Hide Ocean
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.toggleWorldBounds()" id="worldBoundsBtn">
                    üìé Hide Boundaries
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.toggleOceanWaves()" id="oceanWavesBtn">
                    üåä Show Waves
                </button>
            </div>
            
            <!-- Tools -->
            <div class="panel-section">
                <div class="panel-title">Tools</div>
                
                <button class="btn btn-primary" onclick="mapEditor.resetView()">
                    üéØ Reset View
                </button>
                
                <button class="btn btn-warning" onclick="mapEditor.exportData()">
                    üíæ Export Data
                </button>
                
                <button class="btn btn-primary" onclick="mapEditor.importData()">
                    üì• Import Data
                </button>
            </div>
            
            <!-- Controls Guide -->
            <div class="panel-section">
                <div class="panel-title">üéÆ Controls</div>
                
                <div style="font-size: 12px; line-height: 1.6; color: #bdc3c7;">
                    <div style="margin-bottom: 8px;"><strong style="color: #3498db;">Navigation:</strong></div>
                    <div>‚Ä¢ <kbd>W A S D</kbd> - Pan around map</div>
                    <div>‚Ä¢ <kbd>Mouse Wheel</kbd> - Zoom in/out</div>
                    <div>‚Ä¢ <kbd>Left Click + Drag</kbd> - Pan view</div>
                    
                    <div style="margin: 12px 0 8px 0;"><strong style="color: #e74c3c;">Collision Editing:</strong></div>
                    <div>‚Ä¢ <kbd>Shift + A</kbd> - Add point at mouse</div>
                    <div>‚Ä¢ <kbd>Left Click</kbd> - Select/drag point</div>
                    <div>‚Ä¢ <kbd>Delete</kbd> - Remove selected point</div>
                    
                    <div style="margin: 12px 0 8px 0;"><strong style="color: #f39c12;">Actions:</strong></div>
                    <div>‚Ä¢ <kbd>Ctrl + Z</kbd> - Undo last action</div>
                    <div>‚Ä¢ <kbd>Esc</kbd> - Deselect point</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class StandaloneMapEditor {
            constructor() {
                this.canvas = document.getElementById('mapCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // World configuration (from game)
                this.WORLD_WIDTH = 10240;  // Game world width
                this.WORLD_HEIGHT = 7680;  // Game world height
                
                // Editor state
                this.zoom = 0.1;  // Start zoomed out to see full world
                this.minZoom = 0.05;
                this.maxZoom = 3.0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                
                // Display options
                this.showWorldBackground = true;
                this.showWorldBounds = true;
                this.showOceanWaves = false;  // Disabled by default for performance
                
                // Navigation state for WASD
                this.keys = {};
                this.panSpeed = 300; // pixels per second
                this.lastTime = performance.now();
                
                // Undo system
                this.undoStack = [];
                this.maxUndoSteps = 50;
                
                // Islands and collision data
                this.islands = [];
                this.selectedIsland = null;
                this.selectedPointIndex = -1;
                this.mousePos = { x: 0, y: 0 };
                this.worldMousePos = { x: 0, y: 0 };
                this.pointDragStarted = false;
                
                // Drawing settings
                this.pointRadius = 6;
                this.selectedPointRadius = 8;
                this.hoverPointIndex = -1;
                
                // Collision line drawing mode
                this.collisionLineMode = false;
                this.tempCollisionPoints = [];
                
                // Island manipulation
                this.ctrlPressed = false;
                this.islandDragStart = null;
                this.islandResizeMode = false;
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.setupCanvas();
                this.loadExistingGameData();
                // Save initial state after loading data for proper undo functionality
                this.saveInitialUndoState();
                this.updateUndoButton(); // Initialize undo button state
                this.updateStatus('Map Editor Ready', 'info');
                this.startAnimationLoop();
                console.log('üó∫Ô∏è Standalone Map Editor initialized');
            }
            
            loadExistingGameData() {
                // Load existing islands from the game project (exact game coordinates)
                const gameIslands = [
                    {
                        name: 'Saint Kitts Island',
                        x: 2000,    // Game world X coordinate
                        y: 1500,    // Game world Y coordinate
                        width: 800,
                        height: 600,
                        radius: 600, // Collision radius from game
                        image: null, // Will be loaded if available
                        originalImageData: null,
                        isExisting: true,  // Mark as existing game island
                        collision: [
                            { x: 1798.8, y: 968.6 },  // 2000 + (-201.2), 1500 + (-531.4)
                            { x: 1898.5, y: 1010.2 }, // 2000 + (-101.5), 1500 + (-489.8)
                            { x: 2015.5, y: 1159.5 }, // 2000 + (15.5), 1500 + (-340.5)
                            { x: 2128.0, y: 1241.3 }, // 2000 + (128.0), 1500 + (-258.7)
                            { x: 2212.3, y: 1405.1 }, // 2000 + (212.3), 1500 + (-94.9)
                            { x: 2223.6, y: 1496.4 }, // 2000 + (223.6), 1500 + (-3.6)
                            { x: 2273.3, y: 1700.0 }, // 2000 + (273.3), 1500 + (200.0)
                            { x: 2415.6, y: 1885.6 }, // 2000 + (415.6), 1500 + (385.6)
                            { x: 2498.0, y: 1895.8 }, // 2000 + (498.0), 1500 + (395.8)
                            { x: 2513.7, y: 1983.8 }, // 2000 + (513.7), 1500 + (483.8)
                            { x: 2455.2, y: 2032.7 }, // 2000 + (455.2), 1500 + (532.7)
                            { x: 2302.1, y: 2072.8 }, // 2000 + (302.1), 1500 + (572.8)
                            { x: 2280.7, y: 1979.3 }, // 2000 + (280.7), 1500 + (479.3)
                            { x: 2347.0, y: 1942.9 }, // 2000 + (347.0), 1500 + (442.9)
                            { x: 2282.8, y: 1793.8 }, // 2000 + (282.8), 1500 + (293.8)
                            { x: 2211.3, y: 1720.7 }, // 2000 + (211.3), 1500 + (220.7)
                            { x: 2152.4, y: 1700.6 }, // 2000 + (152.4), 1500 + (200.6)
                            { x: 2073.4, y: 1624.3 }, // 2000 + (73.4), 1500 + (124.3)
                            { x: 1997.1, y: 1613.6 }, // 2000 + (-2.9), 1500 + (113.6)
                            { x: 1825.0, y: 1572.1 }, // 2000 + (-175.0), 1500 + (72.1)
                            { x: 1612.4, y: 1383.1 }, // 2000 + (-387.6), 1500 + (-116.9)
                            { x: 1538.3, y: 1277.9 }, // 2000 + (-461.7), 1500 + (-222.1)
                            { x: 1553.8, y: 1203.5 }, // 2000 + (-446.2), 1500 + (-296.5)
                            { x: 1525.1, y: 1147.9 }, // 2000 + (-474.9), 1500 + (-352.1)
                            { x: 1477.7, y: 1078.4 }, // 2000 + (-522.3), 1500 + (-421.6)
                            { x: 1529.3, y: 1002.5 }, // 2000 + (-470.7), 1500 + (-497.5)
                            { x: 1654.5, y: 937.0 },  // 2000 + (-345.5), 1500 + (-563.0)
                            { x: 1768.6, y: 926.2 }   // 2000 + (-231.4), 1500 + (-573.8)
                        ]
                    }
                ];
                
                // Try to load Saint Kitts image automatically
                this.loadSaintKittsImage(gameIslands[0]);
                
                // Convert game data to editor format
                this.islands = gameIslands;
                this.updateIslandSelector();
                
                if (this.islands.length > 0) {
                    this.selectIslandByIndex(0);
                    this.updateStatus(`Loaded ${this.islands.length} existing island(s) from game world`, 'success');
                    
                    // Start with a view of the entire world
                    this.resetToWorldView();
                }
                
                this.render();
            }
            
            loadSaintKittsImage(island) {
                // Try to load the Saint Kitts image from the project
                const img = new Image();
                img.onload = () => {
                    island.image = img;
                    this.updateStatus('Saint Kitts image loaded successfully', 'success');
                    this.render();
                };
                img.onerror = () => {
                    console.log('Could not load Saint Kitts image - using placeholder');
                    this.updateStatus('Using placeholder for Saint Kitts (image not found)', 'info');
                };
                img.src = 'assets/Islands/Saint_Kitts.png'; // Try to load from project
            }
            
            centerOnIsland(island) {
                // Center the view on the specified island
                this.offsetX = -island.x * this.zoom + this.canvas.width / 2;
                this.offsetY = -island.y * this.zoom + this.canvas.height / 2;
            }
            
            setupCanvas() {
                // Set canvas size - much bigger for better navigation
                this.canvas.width = 1600;
                this.canvas.height = 1000;
                
                // Center the view on the game world
                this.offsetX = this.canvas.width / 2 - (this.WORLD_WIDTH * this.zoom) / 2;
                this.offsetY = this.canvas.height / 2 - (this.WORLD_HEIGHT * this.zoom) / 2;
                
                this.render();
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Keyboard events
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // Prevent default actions for navigation keys
                window.addEventListener('keydown', (e) => {
                    if (['KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                        e.preventDefault();
                    }
                });
                
                // Image input
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.handleImageLoad(e);
                });
                
                // Window resize
                window.addEventListener('resize', () => this.handleResize());
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mousePos.x = e.clientX - rect.left;
                this.mousePos.y = e.clientY - rect.top;
                this.updateWorldMousePos();
                
                if (e.button === 0) { // Left click
                    if (this.ctrlPressed && this.selectedIsland) {
                        // Ctrl+Click on island - start island manipulation
                        const islandClicked = this.isPointInIsland(this.worldMousePos, this.selectedIsland);
                        if (islandClicked) {
                            this.islandDragStart = {
                                x: this.worldMousePos.x - this.selectedIsland.x,
                                y: this.worldMousePos.y - this.selectedIsland.y
                            };
                            this.isDragging = true;
                            this.saveUndoState();
                        }
                    } else if (this.collisionLineMode && this.selectedIsland) {
                        // Add point in collision line mode
                        this.tempCollisionPoints.push({
                            x: this.worldMousePos.x,
                            y: this.worldMousePos.y
                        });
                        this.render();
                    } else if (this.selectedIsland) {
                        // Check if clicking on a collision point
                        const pointIndex = this.getPointAtMouse();
                        if (pointIndex !== -1) {
                            this.selectedPointIndex = pointIndex;
                            this.isDragging = true;
                        } else {
                            // Start panning
                            this.isDragging = true;
                            this.dragStart.x = this.mousePos.x;
                            this.dragStart.y = this.mousePos.y;
                        }
                    } else {
                        // Start panning
                        this.isDragging = true;
                        this.dragStart.x = this.mousePos.x;
                        this.dragStart.y = this.mousePos.y;
                    }
                } else if (e.button === 2) { // Right click
                    if (this.collisionLineMode) {
                        // Finish collision line
                        this.finishCollisionLine();
                    } else {
                        // Panning
                        this.isDragging = true;
                        this.dragStart.x = this.mousePos.x;
                        this.dragStart.y = this.mousePos.y;
                    }
                }
                
                this.render();
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mousePos.x = e.clientX - rect.left;
                this.mousePos.y = e.clientY - rect.top;
                this.updateWorldMousePos();
                
                // Update coordinates display
                document.getElementById('coordinatesDisplay').textContent = 
                    `Mouse: (${this.mousePos.x}, ${this.mousePos.y}) | World: (${this.worldMousePos.x.toFixed(1)}, ${this.worldMousePos.y.toFixed(1)})`;
                
                if (this.isDragging) {
                    if (this.islandDragStart && this.selectedIsland) {
                        // Drag entire island
                        this.selectedIsland.x = this.worldMousePos.x - this.islandDragStart.x;
                        this.selectedIsland.y = this.worldMousePos.y - this.islandDragStart.y;
                        this.updateIslandFormValues();
                    } else if (this.selectedPointIndex !== -1 && this.selectedIsland) {
                        // Drag collision point
                        if (!this.pointDragStarted) {
                            this.saveUndoState();
                            this.pointDragStarted = true;
                        }
                        
                        this.selectedIsland.collision[this.selectedPointIndex] = {
                            x: this.worldMousePos.x,
                            y: this.worldMousePos.y
                        };
                        this.updateCollisionPointsList();
                    } else {
                        // Pan view
                        const dx = this.mousePos.x - this.dragStart.x;
                        const dy = this.mousePos.y - this.dragStart.y;
                        this.offsetX += dx;
                        this.offsetY += dy;
                        this.dragStart.x = this.mousePos.x;
                        this.dragStart.y = this.mousePos.y;
                    }
                    this.render();
                }
                
                // Update hover state
                if (this.selectedIsland) {
                    this.hoverPointIndex = this.getPointAtMouse();
                    this.render();
                }
            }
            
            handleMouseUp(e) {
                this.isDragging = false;
                this.selectedPointIndex = -1;
                this.pointDragStarted = false;
                this.islandDragStart = null;
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom * zoomFactor));
                
                // Zoom towards mouse position
                const mouseWorldX = (this.mousePos.x - this.offsetX) / this.zoom;
                const mouseWorldY = (this.mousePos.y - this.offsetY) / this.zoom;
                
                this.zoom = newZoom;
                
                this.offsetX = this.mousePos.x - mouseWorldX * this.zoom;
                this.offsetY = this.mousePos.y - mouseWorldY * this.zoom;
                
                this.render();
            }
            
            handleKeyDown(e) {
                // Handle global shortcuts first (these should work regardless of focus)
                if (e.ctrlKey && e.code === 'KeyZ') {
                    // Ctrl+Z: Undo last action (works globally)
                    e.preventDefault();
                    this.undo();
                    return;
                }
                
                // Don't handle other keys if an input element is focused
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
                    return;
                }
                
                // Store key state for WASD navigation
                this.keys[e.code] = true;
                
                // Track Ctrl key
                if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                    this.ctrlPressed = true;
                    this.canvas.style.cursor = this.selectedIsland ? 'move' : 'crosshair';
                }
                
                // Handle special key combinations
                if (e.shiftKey && e.code === 'KeyA') {
                    // Shift+A: Add collision point at mouse position
                    e.preventDefault();
                    this.addCollisionPointAtMouse();
                    return;
                }
                
                if (e.code === 'Escape') {
                    // Esc: Cancel operations
                    e.preventDefault();
                    if (this.collisionLineMode) {
                        this.cancelCollisionLine();
                    } else {
                        this.selectedPointIndex = -1;
                        this.updateCollisionPointsList();
                        this.render();
                    }
                    return;
                }
                
                if (e.code === 'Delete' && this.selectedPointIndex !== -1 && this.selectedIsland) {
                    // Delete selected collision point
                    this.saveUndoState();
                    this.selectedIsland.collision.splice(this.selectedPointIndex, 1);
                    this.selectedPointIndex = -1;
                    this.updateCollisionPointsList();
                    this.render();
                }
            }
            
            handleKeyUp(e) {
                // Clear key state for WASD navigation
                this.keys[e.code] = false;
                
                // Track Ctrl key release
                if (e.code === 'ControlLeft' || e.code === 'ControlRight') {
                    this.ctrlPressed = false;
                    this.canvas.style.cursor = 'crosshair';
                }
            }
            
            updateWorldMousePos() {
                this.worldMousePos.x = (this.mousePos.x - this.offsetX) / this.zoom;
                this.worldMousePos.y = (this.mousePos.y - this.offsetY) / this.zoom;
            }
            
            getPointAtMouse() {
                if (!this.selectedIsland || !this.selectedIsland.collision) return -1;
                
                for (let i = 0; i < this.selectedIsland.collision.length; i++) {
                    const point = this.selectedIsland.collision[i];
                    const screenX = point.x * this.zoom + this.offsetX;
                    const screenY = point.y * this.zoom + this.offsetY;
                    
                    const distance = Math.sqrt(
                        Math.pow(this.mousePos.x - screenX, 2) + 
                        Math.pow(this.mousePos.y - screenY, 2)
                    );
                    
                    if (distance <= this.pointRadius + 5) {
                        return i;
                    }
                }
                
                return -1;
            }
            
            addCollisionPointAtMouse() {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                if (!this.selectedIsland.collision) {
                    this.selectedIsland.collision = [];
                }
                
                // Save state for undo
                this.saveUndoState();
                
                this.selectedIsland.collision.push({
                    x: this.worldMousePos.x,
                    y: this.worldMousePos.y
                });
                
                this.updateCollisionPointsList();
                
                // Convert to relative coordinates for display
                const relativeX = this.worldMousePos.x - this.selectedIsland.x;
                const relativeY = this.worldMousePos.y - this.selectedIsland.y;
                this.updateStatus(`Added collision point at relative (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`, 'success');
            }
            
            handleImageLoad(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // Create new island with loaded image
                        const islandName = document.getElementById('islandName').value || file.name.split('.')[0];
                        const x = parseFloat(document.getElementById('islandX').value) || 0;
                        const y = parseFloat(document.getElementById('islandY').value) || 0;
                        const radius = parseFloat(document.getElementById('islandRadius').value) || 150;
                        
                        const island = {
                            name: islandName,
                            x: x,
                            y: y,
                            width: img.width || 800,
                            height: img.height || 600,
                            radius: radius,
                            image: img,
                            originalImageData: event.target.result,
                            collision: []
                        };
                        
                        this.islands.push(island);
                        this.updateIslandSelector();
                        this.selectIslandByIndex(this.islands.length - 1);
                        this.updateStatus(`Loaded island: ${islandName}`, 'success');
                        this.render();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            addIsland() {
                const name = document.getElementById('islandName').value || 'New Island';
                const x = parseFloat(document.getElementById('islandX').value) || 0;
                const y = parseFloat(document.getElementById('islandY').value) || 0;
                const radius = parseFloat(document.getElementById('islandRadius').value) || 150;
                
                const width = parseFloat(document.getElementById('islandWidth').value) || 800;
                const height = parseFloat(document.getElementById('islandHeight').value) || 600;
                
                const island = {
                    name: name,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    radius: radius,
                    image: null,
                    originalImageData: null,
                    collision: []
                };
                
                this.islands.push(island);
                this.updateIslandSelector();
                this.selectIslandByIndex(this.islands.length - 1);
                this.updateStatus(`Added island: ${name}`, 'success');
                this.render();
            }
            
            selectIsland() {
                const selector = document.getElementById('islandSelector');
                const index = parseInt(selector.value);
                
                if (index >= 0 && index < this.islands.length) {
                    this.selectIslandByIndex(index);
                } else {
                    this.selectedIsland = null;
                    this.updateCollisionPointsList();
                }
                
                this.render();
            }
            
            selectIslandByIndex(index) {
                this.selectedIsland = this.islands[index];
                this.selectedPointIndex = -1;
                
                // Update form values
                document.getElementById('islandName').value = this.selectedIsland.name;
                document.getElementById('islandX').value = this.selectedIsland.x;
                document.getElementById('islandY').value = this.selectedIsland.y;
                document.getElementById('islandWidth').value = this.selectedIsland.width || 800;
                document.getElementById('islandHeight').value = this.selectedIsland.height || 600;
                document.getElementById('islandRadius').value = this.selectedIsland.radius;
                
                // Show/hide download button
                const downloadBtn = document.getElementById('downloadImageBtn');
                downloadBtn.style.display = this.selectedIsland.originalImageData ? 'block' : 'none';
                
                this.updateCollisionPointsList();
                this.updateStatus(`Selected island: ${this.selectedIsland.name}`, 'info');
            }
            
            updateIslandSelector() {
                const selector = document.getElementById('islandSelector');
                selector.innerHTML = '<option value="">-- Select Island --</option>';
                
                this.islands.forEach((island, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${island.name} (${island.x}, ${island.y})`;
                    selector.appendChild(option);
                });
            }
            
            updateCollisionPointsList() {
                const list = document.getElementById('collisionPointsList');
                
                if (!this.selectedIsland || !this.selectedIsland.collision || this.selectedIsland.collision.length === 0) {
                    list.innerHTML = '<div style="text-align: center; color: #7f8c8d; font-style: italic;">No collision points</div>';
                    return;
                }
                
                list.innerHTML = '';
                this.selectedIsland.collision.forEach((point, index) => {
                    const div = document.createElement('div');
                    div.className = `collision-point ${index === this.selectedPointIndex ? 'selected' : ''}`;
                    
                    // Show both world and relative coordinates
                    const relativeX = point.x - this.selectedIsland.x;
                    const relativeY = point.y - this.selectedIsland.y;
                    
                    div.innerHTML = `
                        <div>${index + 1}: World (${point.x.toFixed(1)}, ${point.y.toFixed(1)})</div>
                        <div style="font-size: 10px; color: #bdc3c7;">Relative (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})</div>
                    `;
                    
                    div.onclick = () => {
                        this.selectedPointIndex = index;
                        this.updateCollisionPointsList();
                        this.render();
                    };
                    list.appendChild(div);
                });
            }
            
            addCollisionPoint() {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                // Save state for undo
                this.saveUndoState();
                
                // Add point at center of view
                const centerX = (-this.offsetX + this.canvas.width / 2) / this.zoom;
                const centerY = (-this.offsetY + this.canvas.height / 2) / this.zoom;
                
                if (!this.selectedIsland.collision) {
                    this.selectedIsland.collision = [];
                }
                
                this.selectedIsland.collision.push({ x: centerX, y: centerY });
                this.updateCollisionPointsList();
                this.updateStatus('Added collision point at center', 'success');
                this.render();
            }
            
            optimizePoints() {
                if (!this.selectedIsland || !this.selectedIsland.collision) {
                    this.updateStatus('No collision points to optimize', 'warning');
                    return;
                }
                
                // Save state for undo
                this.saveUndoState();
                
                const threshold = 10; // Minimum distance between points
                const original = this.selectedIsland.collision.length;
                
                for (let i = this.selectedIsland.collision.length - 1; i > 0; i--) {
                    const point1 = this.selectedIsland.collision[i];
                    const point2 = this.selectedIsland.collision[i - 1];
                    
                    const distance = Math.sqrt(
                        Math.pow(point1.x - point2.x, 2) + 
                        Math.pow(point1.y - point2.y, 2)
                    );
                    
                    if (distance < threshold) {
                        this.selectedIsland.collision.splice(i, 1);
                    }
                }
                
                const removed = original - this.selectedIsland.collision.length;
                this.updateCollisionPointsList();
                this.updateStatus(`Optimized: removed ${removed} redundant points`, 'success');
                this.render();
            }
            
            clearCollision() {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                if (confirm(`Clear all collision points for ${this.selectedIsland.name}?`)) {
                    // Save state for undo
                    this.saveUndoState();
                    
                    this.selectedIsland.collision = [];
                    this.selectedPointIndex = -1;
                    this.updateCollisionPointsList();
                    this.updateStatus('Collision points cleared', 'success');
                    this.render();
                }
            }
            
            async propagateToProject() {
                if (!this.selectedIsland || !this.selectedIsland.collision || this.selectedIsland.collision.length === 0) {
                    this.updateStatus('No collision data to propagate', 'warning');
                    return;
                }
                
                try {
                    this.updateStatus('Propagating to project...', 'info');
                    this.setProgress(20);
                    
                    // Generate collision code
                    const collisionCode = this.generateCollisionCode();
                    this.setProgress(50);
                    
                    // Copy to clipboard
                    await navigator.clipboard.writeText(collisionCode);
                    this.setProgress(80);
                    
                    // Show success message
                    this.setProgress(100);
                    this.updateStatus('‚úÖ Code copied to clipboard! Paste into map.js', 'success');
                    
                    // Show integration instructions
                    this.showIntegrationDialog(collisionCode);
                    
                    setTimeout(() => {
                        this.setProgress(0);
                        this.updateStatus('Ready for editing', 'info');
                    }, 3000);
                    
                } catch (error) {
                    console.error('Propagation error:', error);
                    this.updateStatus('‚ùå Failed to propagate to project', 'warning');
                    this.setProgress(0);
                }
            }
            
            generateCollisionCode() {
                const island = this.selectedIsland;
                const points = island.collision;
                
                // Convert world coordinates back to relative coordinates for the game
                const relativePoints = points.map(point => ({
                    x: point.x - island.x,
                    y: point.y - island.y
                }));
                
                let code = `generateCustomOutline(island) {\n`;
                code += `    // MANUAL COLLISION OUTLINE CONFIGURATION\n`;
                code += `    // ${island.name} - ${points.length} collision points (updated with map editor)\n\n`;
                code += `    // ${island.name} - ${points.length} collision points\n`;
                code += `    const saintKittsIslandPoints = [\n`;
                
                relativePoints.forEach((point, index) => {
                    const comma = index < relativePoints.length - 1 ? ',' : '';
                    code += `        { x: ${point.x.toFixed(1)}, y: ${point.y.toFixed(1)} }${comma}\n`;
                });
                
                code += `    ];\n\n`;
                code += `    // Usage in generateCustomOutline():\n`;
                code += `    return {\n`;
                code += `        points: saintKittsIslandPoints,\n`;
                code += `        bounds: this.calculateOutlineBounds(saintKittsIslandPoints)\n`;
                code += `    };\n`;
                code += `}`;
                
                return code;
            }
            
            showIntegrationDialog(code) {
                const relativePoints = this.selectedIsland.collision.map(point => ({
                    x: point.x - this.selectedIsland.x,
                    y: point.y - this.selectedIsland.y
                }));
                
                const dialog = `
INTEGRATION COMPLETE! üöÄ

‚úÖ Collision code copied to clipboard
‚úÖ Island: ${this.selectedIsland.name}
‚úÖ Position: (${this.selectedIsland.x}, ${this.selectedIsland.y})
‚úÖ Points: ${this.selectedIsland.collision.length} collision points
‚úÖ Coordinates: Converted to relative positions

NEXT STEPS:
1. Open js/map.js in your editor
2. Find the generateCustomOutline() method (around line 125)
3. Replace it with the clipboard code
4. Save and refresh your game

The collision points are automatically converted to the correct 
relative coordinates for your project!
                `;
                
                alert(dialog);
            }
            
            updateStatus(message, type = 'info') {
                const indicator = document.getElementById('statusIndicator');
                indicator.textContent = message;
                indicator.className = `status-indicator status-${type}`;
                
                if (type === 'success') {
                    indicator.classList.add('pulsing');
                    setTimeout(() => indicator.classList.remove('pulsing'), 2000);
                }
            }
            
            setProgress(percent) {
                const fill = document.getElementById('progressFill');
                fill.style.width = percent + '%';
            }
            
            zoomIn() {
                this.zoom = Math.min(this.maxZoom, this.zoom * 1.2);
                this.render();
            }
            
            zoomOut() {
                this.zoom = Math.max(this.minZoom, this.zoom * 0.8);
                this.render();
            }
            
            resetZoom() {
                this.zoom = 1.0;
                this.offsetX = -this.canvas.width / 2;
                this.offsetY = -this.canvas.height / 2;
                this.render();
            }
            
            resetToWorldView() {
                // Reset view to show the entire game world
                const worldAspect = this.WORLD_WIDTH / this.WORLD_HEIGHT;
                const canvasAspect = this.canvas.width / this.canvas.height;
                
                if (worldAspect > canvasAspect) {
                    // World is wider - fit to width
                    this.zoom = (this.canvas.width * 0.9) / this.WORLD_WIDTH;
                } else {
                    // World is taller - fit to height
                    this.zoom = (this.canvas.height * 0.9) / this.WORLD_HEIGHT;
                }
                
                // Center the world in the canvas
                this.offsetX = this.canvas.width / 2 - (this.WORLD_WIDTH * this.zoom) / 2;
                this.offsetY = this.canvas.height / 2 - (this.WORLD_HEIGHT * this.zoom) / 2;
                
                this.render();
            }
            
            resetView() {
                if (this.selectedIsland) {
                    // Center on selected island
                    this.offsetX = -this.selectedIsland.x * this.zoom + this.canvas.width / 2;
                    this.offsetY = -this.selectedIsland.y * this.zoom + this.canvas.height / 2;
                } else {
                    this.resetZoom();
                }
                this.render();
            }
            
            exportData() {
                const data = {
                    islands: this.islands.map(island => ({
                        name: island.name,
                        x: island.x,
                        y: island.y,
                        radius: island.radius,
                        collision: island.collision
                    }))
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'map-editor-data.json';
                a.click();
                
                URL.revokeObjectURL(url);
                this.updateStatus('Data exported successfully', 'success');
            }
            
            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            
                            if (data.islands) {
                                this.islands = data.islands.map(island => ({
                                    ...island,
                                    image: null // Images need to be reloaded
                                }));
                                
                                this.updateIslandSelector();
                                this.selectedIsland = null;
                                this.updateCollisionPointsList();
                                this.render();
                                this.updateStatus('Data imported successfully', 'success');
                            }
                        } catch (error) {
                            this.updateStatus('Failed to import data', 'warning');
                            console.error('Import error:', error);
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            }
            
            handleResize() {
                // Handle window resize
                const wrapper = document.querySelector('.canvas-wrapper');
                this.canvas.width = wrapper.clientWidth;
                this.canvas.height = wrapper.clientHeight;
                this.render();
            }
            
            startAnimationLoop() {
                // Start the animation loop for WASD navigation
                const animate = (currentTime) => {
                    const deltaTime = (currentTime - this.lastTime) / 1000;
                    this.lastTime = currentTime;
                    
                    this.updateNavigation(deltaTime);
                    requestAnimationFrame(animate);
                };
                
                requestAnimationFrame(animate);
            }
            
            updateNavigation(deltaTime) {
                let moved = false;
                const moveDistance = this.panSpeed * deltaTime;
                
                // WASD navigation
                if (this.keys['KeyW']) {
                    this.offsetY += moveDistance;
                    moved = true;
                }
                if (this.keys['KeyS']) {
                    this.offsetY -= moveDistance;
                    moved = true;
                }
                if (this.keys['KeyA']) {
                    this.offsetX += moveDistance;
                    moved = true;
                }
                if (this.keys['KeyD']) {
                    this.offsetX -= moveDistance;
                    moved = true;
                }
                
                if (moved) {
                    this.render();
                }
            }
            
            saveUndoState() {
                // Don't save undo state if islands array is empty (unless it's intentionally empty after deletion)
                if (this.islands.length === 0 && this.undoStack.length === 0) {
                    return;
                }
                
                // Save current state for undo functionality
                const state = {
                    islands: JSON.parse(JSON.stringify(this.islands)),
                    selectedIslandIndex: this.selectedIsland ? this.islands.indexOf(this.selectedIsland) : -1
                };
                
                this.undoStack.push(state);
                
                // Limit undo stack size
                if (this.undoStack.length > this.maxUndoSteps) {
                    this.undoStack.shift();
                }
                
                this.updateUndoButton();
            }
            
            saveInitialUndoState() {
                // Save the initial state after loading game data
                if (this.islands.length > 0) {
                    const state = {
                        islands: JSON.parse(JSON.stringify(this.islands)),
                        selectedIslandIndex: this.selectedIsland ? this.islands.indexOf(this.selectedIsland) : -1
                    };
                    
                    this.undoStack.push(state);
                    console.log('Initial undo state saved with', this.islands.length, 'islands');
                }
            }
            
            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    // Disable if no undo actions available (need at least 2 states: initial + current)
                    const canUndo = this.undoStack.length > 1;
                    undoBtn.disabled = !canUndo;
                    
                    if (!canUndo) {
                        undoBtn.title = 'No actions to undo';
                    } else {
                        const availableUndos = this.undoStack.length - 1; // Subtract 1 for initial state
                        undoBtn.title = `Undo last action (${availableUndos} action${availableUndos !== 1 ? 's' : ''} available) - Ctrl+Z`;
                    }
                }
            }
            
            undo() {
                if (this.undoStack.length === 0) {
                    this.updateStatus('Nothing to undo', 'warning');
                    return;
                }
                
                // Don't allow undo if we only have the initial state
                if (this.undoStack.length === 1) {
                    this.updateStatus('Already at initial state', 'warning');
                    return;
                }
                
                // Remove current state and get previous state
                this.undoStack.pop(); // Remove current state
                const state = this.undoStack[this.undoStack.length - 1]; // Get previous state (but keep it in stack)
                
                // Restore state
                this.islands = JSON.parse(JSON.stringify(state.islands)); // Deep clone to avoid reference issues
                
                // Restore selected island
                if (state.selectedIslandIndex >= 0 && state.selectedIslandIndex < this.islands.length) {
                    this.selectedIsland = this.islands[state.selectedIslandIndex];
                } else {
                    this.selectedIsland = null;
                }
                
                // Update UI
                this.updateIslandSelector();
                this.updateCollisionPointsList();
                this.selectedPointIndex = -1;
                this.updateUndoButton();
                
                this.updateStatus(`Undo completed (${this.undoStack.length - 1} more available)`, 'success');
                this.render();
            }
            
            render() {
                // Clear canvas with deep ocean color
                this.ctx.fillStyle = '#0a1a2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw world background
                if (this.showWorldBackground) {
                    this.drawWorldBackground();
                }
                
                // Draw world boundaries
                if (this.showWorldBounds) {
                    this.drawWorldBounds();
                }
                
                // Draw coordinate grid
                this.drawGrid();
                
                // Draw islands
                this.islands.forEach((island, index) => {
                    this.drawIsland(island, index === this.islands.indexOf(this.selectedIsland));
                });
                
                // Draw UI elements
                this.drawUI();
            }
            
            drawWorldBackground() {
                // Draw the game world ocean background
                const worldScreenX = this.offsetX;
                const worldScreenY = this.offsetY;
                const worldScreenWidth = this.WORLD_WIDTH * this.zoom;
                const worldScreenHeight = this.WORLD_HEIGHT * this.zoom;
                
                // Ocean gradient
                const gradient = this.ctx.createLinearGradient(
                    worldScreenX, worldScreenY,
                    worldScreenX + worldScreenWidth, worldScreenY + worldScreenHeight
                );
                gradient.addColorStop(0, '#1e3a5f');
                gradient.addColorStop(0.5, '#2c5f8a');
                gradient.addColorStop(1, '#1e3a5f');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(worldScreenX, worldScreenY, worldScreenWidth, worldScreenHeight);
                
                // Optional: Draw simplified wave pattern
                if (this.showOceanWaves) {
                    this.drawSimpleWaves();
                }
            }
            
            drawWorldBounds() {
                // Draw the game world boundaries
                const worldScreenX = this.offsetX;
                const worldScreenY = this.offsetY;
                const worldScreenWidth = this.WORLD_WIDTH * this.zoom;
                const worldScreenHeight = this.WORLD_HEIGHT * this.zoom;
                
                this.ctx.strokeStyle = '#3498db';
                this.ctx.lineWidth = 3;
                this.ctx.strokeRect(worldScreenX, worldScreenY, worldScreenWidth, worldScreenHeight);
                
                // Draw corner markers
                const markerSize = 20;
                this.ctx.fillStyle = '#3498db';
                
                // Top-left
                this.ctx.fillRect(worldScreenX - 2, worldScreenY - 2, markerSize, 4);
                this.ctx.fillRect(worldScreenX - 2, worldScreenY - 2, 4, markerSize);
                
                // Top-right
                this.ctx.fillRect(worldScreenX + worldScreenWidth - markerSize + 2, worldScreenY - 2, markerSize, 4);
                this.ctx.fillRect(worldScreenX + worldScreenWidth - 2, worldScreenY - 2, 4, markerSize);
                
                // Bottom-left
                this.ctx.fillRect(worldScreenX - 2, worldScreenY + worldScreenHeight - 2, markerSize, 4);
                this.ctx.fillRect(worldScreenX - 2, worldScreenY + worldScreenHeight - markerSize + 2, 4, markerSize);
                
                // Bottom-right
                this.ctx.fillRect(worldScreenX + worldScreenWidth - markerSize + 2, worldScreenY + worldScreenHeight - 2, markerSize, 4);
                this.ctx.fillRect(worldScreenX + worldScreenWidth - 2, worldScreenY + worldScreenHeight - markerSize + 2, 4, markerSize);
                
                // Add world size label
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(
                    `Game World: ${this.WORLD_WIDTH}x${this.WORLD_HEIGHT}px`,
                    worldScreenX + worldScreenWidth / 2,
                    worldScreenY - 10
                );
            }
            
            drawSimpleWaves() {
                // Simple wave animation for visual effect
                const time = Date.now() * 0.001;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;
                
                const waveSpacing = 100 * this.zoom;
                const amplitude = 10 * this.zoom;
                
                for (let y = this.offsetY; y < this.offsetY + this.WORLD_HEIGHT * this.zoom; y += waveSpacing) {
                    this.ctx.beginPath();
                    for (let x = this.offsetX; x < this.offsetX + this.WORLD_WIDTH * this.zoom; x += 10) {
                        const waveY = y + Math.sin((x - this.offsetX) * 0.01 + time) * amplitude;
                        if (x === this.offsetX) {
                            this.ctx.moveTo(x, waveY);
                        } else {
                            this.ctx.lineTo(x, waveY);
                        }
                    }
                    this.ctx.stroke();
                }
            }
            
            drawGrid() {
                // Draw coordinate grid with world-based spacing
                const majorGridSize = 1000 * this.zoom;  // 1000px world units
                const minorGridSize = 500 * this.zoom;   // 500px world units
                
                // Only draw grid if it's visible enough
                if (majorGridSize < 10) return;
                
                // Calculate grid bounds based on world coordinates
                const worldLeft = -this.offsetX / this.zoom;
                const worldTop = -this.offsetY / this.zoom;
                const worldRight = (this.canvas.width - this.offsetX) / this.zoom;
                const worldBottom = (this.canvas.height - this.offsetY) / this.zoom;
                
                // Major grid lines
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                this.ctx.lineWidth = 1;
                
                // Vertical major lines
                for (let worldX = Math.floor(worldLeft / 1000) * 1000; worldX <= worldRight; worldX += 1000) {
                    const screenX = worldX * this.zoom + this.offsetX;
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenX, 0);
                    this.ctx.lineTo(screenX, this.canvas.height);
                    this.ctx.stroke();
                    
                    // Grid labels
                    if (this.zoom > 0.1) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        this.ctx.font = '12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(worldX.toString(), screenX, 20);
                    }
                }
                
                // Horizontal major lines
                for (let worldY = Math.floor(worldTop / 1000) * 1000; worldY <= worldBottom; worldY += 1000) {
                    const screenY = worldY * this.zoom + this.offsetY;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenY);
                    this.ctx.lineTo(this.canvas.width, screenY);
                    this.ctx.stroke();
                    
                    // Grid labels
                    if (this.zoom > 0.1) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        this.ctx.font = '12px Arial';
                        this.ctx.textAlign = 'left';
                        this.ctx.fillText(worldY.toString(), 5, screenY - 5);
                    }
                }
                
                // Minor grid lines (only when zoomed in enough)
                if (minorGridSize > 20) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                    this.ctx.lineWidth = 1;
                    
                    // Minor vertical lines
                    for (let worldX = Math.floor(worldLeft / 500) * 500; worldX <= worldRight; worldX += 500) {
                        if (worldX % 1000 !== 0) {  // Skip major grid lines
                            const screenX = worldX * this.zoom + this.offsetX;
                            this.ctx.beginPath();
                            this.ctx.moveTo(screenX, 0);
                            this.ctx.lineTo(screenX, this.canvas.height);
                            this.ctx.stroke();
                        }
                    }
                    
                    // Minor horizontal lines
                    for (let worldY = Math.floor(worldTop / 500) * 500; worldY <= worldBottom; worldY += 500) {
                        if (worldY % 1000 !== 0) {  // Skip major grid lines
                            const screenY = worldY * this.zoom + this.offsetY;
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, screenY);
                            this.ctx.lineTo(this.canvas.width, screenY);
                            this.ctx.stroke();
                        }
                    }
                }
            }
            
            drawIsland(island, isSelected) {
                const screenX = island.x * this.zoom + this.offsetX;
                const screenY = island.y * this.zoom + this.offsetY;
                const screenRadius = island.radius * this.zoom;
                
                // Use configured dimensions if available
                // Match the game's rendering - use radius * 2 for dimensions
                const width = island.radius * 2 * this.zoom;
                const height = island.radius * 2 * this.zoom;
                
                // Draw island image or placeholder
                if (island.image) {
                    this.ctx.drawImage(
                        island.image,
                        screenX - width / 2,
                        screenY - height / 2,
                        width,
                        height
                    );
                    
                    // Draw dimension outline when selected
                    if (isSelected) {
                        this.ctx.strokeStyle = '#3498db';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(
                            screenX - width / 2,
                            screenY - height / 2,
                            width,
                            height
                        );
                    }
                } else {
                    // Draw placeholder rectangle
                    this.ctx.fillStyle = isSelected ? '#27ae60' : '#8fbc8f';
                    this.ctx.fillRect(
                        screenX - width / 2,
                        screenY - height / 2,
                        width,
                        height
                    );
                }
                
                // Draw island collision radius outline
                this.ctx.strokeStyle = isSelected ? '#3498db' : '#2ecc71';
                this.ctx.lineWidth = isSelected ? 3 : 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw island name and info
                this.ctx.fillStyle = island.isExisting ? '#e74c3c' : '#ffffff';
                this.ctx.font = `${Math.max(12, 14 * this.zoom)}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(
                    island.isExisting ? `${island.name} (EXISTING)` : island.name, 
                    screenX, 
                    screenY - height / 2 - 20
                );
                
                if (isSelected) {
                    this.ctx.font = `${Math.max(10, 12 * this.zoom)}px Arial`;
                    this.ctx.fillText(`${Math.round(island.width)}x${Math.round(island.height)}px`, screenX, screenY - height / 2 - 5);
                    
                    if (island.isExisting) {
                        this.ctx.fillStyle = '#f39c12';
                        this.ctx.fillText('Game World Island', screenX, screenY + height / 2 + 15);
                    }
                }
                
                // Draw collision points
                if (island.collision && island.collision.length > 0) {
                    this.drawCollisionOutline(island);
                }
            }
            
            drawCollisionOutline(island) {
                if (!island.collision || island.collision.length < 2) return;
                
                const isSelected = island === this.selectedIsland;
                
                // Draw collision outline
                this.ctx.strokeStyle = isSelected ? '#e74c3c' : '#f39c12';
                this.ctx.lineWidth = isSelected ? 2 : 1;
                this.ctx.beginPath();
                
                const firstPoint = island.collision[0];
                this.ctx.moveTo(
                    firstPoint.x * this.zoom + this.offsetX,
                    firstPoint.y * this.zoom + this.offsetY
                );
                
                for (let i = 1; i < island.collision.length; i++) {
                    const point = island.collision[i];
                    this.ctx.lineTo(
                        point.x * this.zoom + this.offsetX,
                        point.y * this.zoom + this.offsetY
                    );
                }
                
                this.ctx.closePath();
                this.ctx.stroke();
                
                // Draw collision points
                island.collision.forEach((point, index) => {
                    const screenX = point.x * this.zoom + this.offsetX;
                    const screenY = point.y * this.zoom + this.offsetY;
                    
                    let pointColor = '#3498db';
                    let radius = this.pointRadius;
                    
                    if (isSelected && index === this.selectedPointIndex) {
                        pointColor = '#e74c3c';
                        radius = this.selectedPointRadius;
                    } else if (isSelected && index === this.hoverPointIndex) {
                        pointColor = '#f39c12';
                        radius = this.selectedPointRadius;
                    }
                    
                    this.ctx.fillStyle = pointColor;
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw point index
                    if (isSelected && this.zoom > 0.5) {
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = '10px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText((index + 1).toString(), screenX, screenY + 3);
                    }
                });
            }
            
            drawUI() {
                // Draw zoom and world info
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(10, this.canvas.height - 80, 250, 70);
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Zoom: ${(this.zoom * 100).toFixed(1)}%`, 15, this.canvas.height - 60);
                this.ctx.fillText(`World: ${this.WORLD_WIDTH}x${this.WORLD_HEIGHT}px`, 15, this.canvas.height - 45);
                this.ctx.fillText(`Undo: ${this.undoStack.length}/${this.maxUndoSteps}`, 15, this.canvas.height - 30);
                
                // World coordinate at mouse position
                const worldX = (this.mousePos.x - this.offsetX) / this.zoom;
                const worldY = (this.mousePos.y - this.offsetY) / this.zoom;
                this.ctx.fillText(`World Pos: (${worldX.toFixed(0)}, ${worldY.toFixed(0)})`, 15, this.canvas.height - 15);
                
                // Draw collision line mode indicator
                if (this.collisionLineMode) {
                    this.ctx.fillStyle = 'rgba(231, 76, 60, 0.9)';
                    this.ctx.fillRect(200, this.canvas.height - 50, 200, 40);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('COLLISION LINE MODE', 300, this.canvas.height - 25);
                    
                    // Draw temp collision points
                    if (this.tempCollisionPoints.length > 0) {
                        this.drawTempCollisionLine();
                    }
                }
            }
        
            // New methods for enhanced functionality
            toggleCollisionLineMode() {
                this.collisionLineMode = !this.collisionLineMode;
                this.tempCollisionPoints = [];
                
                const btn = document.getElementById('collisionLineModeBtn');
                if (this.collisionLineMode) {
                    btn.textContent = 'üî¥ Stop Drawing';
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-danger');
                    this.updateStatus('Click to add points, right-click to finish', 'info');
                } else {
                    btn.textContent = '‚úèÔ∏è Draw Collision Line';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-primary');
                    this.updateStatus('Collision line mode disabled', 'info');
                }
                
                this.render();
            }
            
            finishCollisionLine() {
                if (this.tempCollisionPoints.length > 2) {
                    this.saveUndoState();
                    this.selectedIsland.collision = this.selectedIsland.collision.concat(this.tempCollisionPoints);
                    this.updateCollisionPointsList();
                    this.updateStatus(`Added ${this.tempCollisionPoints.length} collision points`, 'success');
                } else {
                    this.updateStatus('Need at least 3 points for collision line', 'warning');
                }
                
                this.tempCollisionPoints = [];
                this.toggleCollisionLineMode();
            }
            
            cancelCollisionLine() {
                this.tempCollisionPoints = [];
                this.collisionLineMode = false;
                const btn = document.getElementById('collisionLineModeBtn');
                btn.textContent = '‚úèÔ∏è Draw Collision Line';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-primary');
                this.updateStatus('Collision line cancelled', 'info');
                this.render();
            }
            
            drawTempCollisionLine() {
                if (this.tempCollisionPoints.length === 0) return;
                
                this.ctx.strokeStyle = '#e74c3c';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                
                const firstPoint = this.tempCollisionPoints[0];
                this.ctx.moveTo(
                    firstPoint.x * this.zoom + this.offsetX,
                    firstPoint.y * this.zoom + this.offsetY
                );
                
                for (let i = 1; i < this.tempCollisionPoints.length; i++) {
                    const point = this.tempCollisionPoints[i];
                    this.ctx.lineTo(
                        point.x * this.zoom + this.offsetX,
                        point.y * this.zoom + this.offsetY
                    );
                }
                
                // Draw line to mouse position
                this.ctx.lineTo(
                    this.worldMousePos.x * this.zoom + this.offsetX,
                    this.worldMousePos.y * this.zoom + this.offsetY
                );
                
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw temp points
                this.tempCollisionPoints.forEach(point => {
                    const screenX = point.x * this.zoom + this.offsetX;
                    const screenY = point.y * this.zoom + this.offsetY;
                    
                    this.ctx.fillStyle = '#e74c3c';
                    this.ctx.beginPath();
                    this.ctx.arc(screenX, screenY, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            isPointInIsland(point, island) {
                const width = (island.width || 800) * 0.5;
                const height = (island.height || 600) * 0.5;
                
                return point.x >= island.x - width &&
                       point.x <= island.x + width &&
                       point.y >= island.y - height &&
                       point.y <= island.y + height;
            }
            
            updateIslandFormValues() {
                if (!this.selectedIsland) return;
                
                document.getElementById('islandX').value = Math.round(this.selectedIsland.x);
                document.getElementById('islandY').value = Math.round(this.selectedIsland.y);
            }
            
            downloadSelectedIslandImage() {
                if (!this.selectedIsland || !this.selectedIsland.originalImageData) {
                    this.updateStatus('No image to download', 'warning');
                    return;
                }
                
                // Create download link
                const link = document.createElement('a');
                link.href = this.selectedIsland.originalImageData;
                link.download = `${this.selectedIsland.name.replace(/\s+/g, '_')}.png`;
                link.click();
                
                this.updateStatus(`Downloaded ${this.selectedIsland.name} image`, 'success');
                
                // Show instructions
                setTimeout(() => {
                    this.copyImageInstructions();
                }, 500);
            }
            
            copyImageInstructions() {
                const instructions = `Island Image Installation Instructions:

1. Download the island image (if not already done)
2. Move the downloaded image to: assets/Islands/
3. Rename the file to match the island name (e.g., "Saint_Kitts.png")
4. The image will be automatically loaded when the game starts

Note: Since this is a client-side editor, you need to manually place the image in your project folder.`;
                
                navigator.clipboard.writeText(instructions);
                this.updateStatus('Installation instructions copied to clipboard!', 'success');
                alert(instructions);
            }
            
            generateCodeWithPrompt() {
                if (!this.selectedIsland) {
                    this.updateStatus('Please select an island first', 'warning');
                    return;
                }
                
                const island = this.selectedIsland;
                const hasCollision = island.collision && island.collision.length > 0;
                
                // Generate the complete code and prompt
                let output = `=== ISLAND CONFIGURATION CODE ===\n\n`;
                output += `Island Name: ${island.name}\n`;
                output += `Position: (${island.x}, ${island.y})\n`;
                output += `Dimensions: ${island.width}x${island.height} pixels\n`;
                output += `Collision Radius: ${island.radius}\n\n`;
                
                output += `=== INSTRUCTIONS FOR ADDING TO GAME ===\n\n`;
                output += `1. Save island image as: assets/Islands/${island.name.replace(/\s+/g, '_')}.png\n\n`;
                
                output += `2. Add to islandConfigurations in js/map.js:\n\n`;
                output += `{
`;
                output += `    name: '${island.name}',
`;
                output += `    x: ${island.x},
`;
                output += `    y: ${island.y},
`;
                output += `    radius: ${island.radius},
`;
                output += `    width: ${island.width},
`;
                output += `    height: ${island.height},
`;
                output += `    hasCustomOutline: ${hasCollision}\n`;
                output += `}\n\n`;
                
                if (hasCollision) {
                    output += `3. Add collision outline to generateCustomOutline() method:\n\n`;
                    output += `if (island.name === '${island.name}') {\n`;
                    output += `    const points = [\n`;
                    
                    // Convert to relative coordinates
                    island.collision.forEach((point, index) => {
                        const relX = point.x - island.x;
                        const relY = point.y - island.y;
                        const comma = index < island.collision.length - 1 ? ',' : '';
                        output += `        { x: ${relX.toFixed(1)}, y: ${relY.toFixed(1)} }${comma}\n`;
                    });
                    
                    output += `    ];\n`;
                    output += `    return {\n`;
                    output += `        points: points,\n`;
                    output += `        bounds: this.calculateOutlineBounds(points)\n`;
                    output += `    };\n`;
                    output += `}\n\n`;
                }
                
                output += `=== PROMPT FOR AI ASSISTANT ===\n\n`;
                output += `Please help me add a new island to the GORET game:\n\n`;
                output += `1. The island should be named "${island.name}" and positioned at (${island.x}, ${island.y})\n`;
                output += `2. It should have dimensions of ${island.width}x${island.height} pixels\n`;
                output += `3. The collision detection radius should be ${island.radius} pixels\n`;
                
                if (hasCollision) {
                    output += `4. It has a custom collision outline with ${island.collision.length} points (provided above)\n`;
                } else {
                    output += `4. It should use circular collision detection (no custom outline)\n`;
                }
                
                output += `\nPlease update the necessary files to integrate this island into the game.`;
                
                // Copy to clipboard
                navigator.clipboard.writeText(output);
                this.updateStatus('Code and prompt copied to clipboard!', 'success');
                
                // Show preview
                const preview = output.substring(0, 500) + '...\n\n[Full content copied to clipboard]';
                alert(preview);
            }
            
            toggleWorldBackground() {
                this.showWorldBackground = !this.showWorldBackground;
                const btn = document.getElementById('worldBackgroundBtn');
                btn.textContent = this.showWorldBackground ? 'üåä Hide Ocean' : 'üåä Show Ocean';
                this.render();
            }
            
            toggleWorldBounds() {
                this.showWorldBounds = !this.showWorldBounds;
                const btn = document.getElementById('worldBoundsBtn');
                btn.textContent = this.showWorldBounds ? 'üìé Hide Boundaries' : 'üìé Show Boundaries';
                this.render();
            }
            
            toggleOceanWaves() {
                this.showOceanWaves = !this.showOceanWaves;
                const btn = document.getElementById('oceanWavesBtn');
                btn.textContent = this.showOceanWaves ? 'üåä Hide Waves' : 'üåä Show Waves';
                this.render();
            }
        }
        
        // Initialize the map editor
        let mapEditor;
        window.addEventListener('DOMContentLoaded', () => {
            mapEditor = new StandaloneMapEditor();
        });
    </script>
</body>
</html>
