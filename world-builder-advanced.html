<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GORET - Advanced World Builder v2.1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0f1a;
            color: #ecf0f1;
            overflow: hidden;
        }

        .main-container {
            display: flex;
            height: 100vh;
        }

        .left-panel {
            width: 350px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-right: 3px solid #3498db;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 5px 0 15px rgba(0,0,0,0.3);
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background: #1e3a5f;
        }

        .right-panel {
            width: 300px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border-left: 3px solid #3498db;
            padding: 20px;
            overflow-y: auto;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        .header h1 {
            font-size: 20px;
            color: #3498db;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
            margin-bottom: 5px;
        }

        .header .version {
            font-size: 12px;
            color: #95a5a6;
            font-weight: normal;
        }

        .section {
            margin-bottom: 25px;
            background: rgba(44, 62, 80, 0.6);
            border-radius: 8px;
            padding: 18px;
            border: 1px solid rgba(52, 152, 219, 0.2);
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin: 6px 0;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2980b9, #1abc9c);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #229954, #1e8449);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #d68910);
            color: white;
        }

        .btn-warning:hover {
            background: linear-gradient(135deg, #d68910, #b7950b);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        .input-group {
            margin: 10px 0;
        }

        .input-group label {
            display: block;
            font-size: 12px;
            color: #bdc3c7;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(44, 62, 80, 0.8);
            border: 1px solid #3498db;
            border-radius: 5px;
            color: #ecf0f1;
            font-size: 12px;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #2ecc71;
            box-shadow: 0 0 5px rgba(46, 204, 113, 0.3);
        }

        #worldCanvas {
            display: block;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            background: #1e3a5f;
        }

        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #00ff00;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #3498db;
        }

        .debug-panel {
            position: absolute;
            top: 20px;
            right: 330px;
            width: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #e74c3c;
            border-radius: 8px;
            padding: 15px;
            color: #ecf0f1;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            display: none;
            z-index: 10000;
            max-height: 500px;
            overflow-y: auto;
        }

        .debug-header {
            background: #e74c3c;
            color: white;
            padding: 8px 12px;
            margin: -15px -15px 10px -15px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-close {
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }

        .performance-monitor {
            position: absolute;
            top: 20px;
            left: 370px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #f39c12;
            color: #f39c12;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            display: none;
            z-index: 9999;
        }

        .collision-info {
            background: rgba(52, 73, 94, 0.9);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
        }

        .island-list {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(44, 62, 80, 0.6);
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
        }

        .island-item {
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .island-item:hover {
            background: rgba(52, 152, 219, 0.2);
            border-left-color: #3498db;
        }

        .island-item.selected {
            background: rgba(231, 76, 60, 0.2);
            border-left-color: #e74c3c;
        }

        .grid-controls {
            display: flex;
            gap: 5px;
            align-items: center;
            margin: 10px 0;
        }

        .grid-controls input[type="range"] {
            flex: 1;
        }

        .tool-palette {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 15px 0;
        }

        .advanced-controls {
            display: none;
        }

        .advanced-controls.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Left Panel: Tools & Controls -->
        <div class="left-panel">
            <div class="header">
                <h1>üåä GORET World Builder</h1>
                <div class="version">Advanced v2.1.0 - Professional Edition</div>
            </div>

            <!-- View Controls -->
            <div class="section">
                <div class="section-title">üîç View Controls</div>
                <button class="btn btn-primary" onclick="worldBuilder.toggleGrid()">
                    <span id="gridToggleText">Hide Grid</span> (G)
                </button>
                <div class="grid-controls">
                    <label>Grid Size:</label>
                    <input type="range" id="gridSizeSlider" min="50" max="200" value="100" 
                           onchange="worldBuilder.setGridSize(this.value)">
                    <span id="gridSizeValue">100px</span>
                </div>
                <button class="btn btn-primary" onclick="worldBuilder.fitWorld()">Fit World (F)</button>
                <button class="btn btn-primary" onclick="worldBuilder.resetView()">Reset View (R)</button>
            </div>

            <!-- Tool Palette -->
            <div class="section">
                <div class="section-title">üõ†Ô∏è Tools</div>
                <div class="tool-palette">
                    <button class="btn btn-primary active" id="selectTool" onclick="worldBuilder.setTool('select')">
                        üéØ Select
                    </button>
                    <button class="btn btn-success" id="addIslandTool" onclick="worldBuilder.setTool('addIsland')">
                        üèùÔ∏è Add Island
                    </button>
                    <button class="btn btn-warning" id="editCollisionTool" onclick="worldBuilder.setTool('editCollision')">
                        üí• Collision
                    </button>
                    <button class="btn btn-primary" id="lineTool" onclick="worldBuilder.setTool('line')">
                        ‚úèÔ∏è Draw Line
                    </button>
                </div>
            </div>

            <!-- World Management -->
            <div class="section">
                <div class="section-title">üåç World Management</div>
                <button class="btn btn-success" onclick="worldBuilder.loadFromServer()">
                    üì• Load from Server
                </button>
                <button class="btn btn-warning" onclick="worldBuilder.saveToServer()">
                    üíæ Save to Server
                </button>
                <button class="btn btn-primary" onclick="worldBuilder.importJSON()">
                    üìÇ Import JSON
                </button>
                <button class="btn btn-primary" onclick="worldBuilder.exportJSON()">
                    üì§ Export JSON
                </button>
            </div>

            <!-- Advanced Tools -->
            <div class="section">
                <div class="section-title">‚ö° Advanced Tools</div>
                <button class="btn btn-warning" onclick="worldBuilder.optimizeAll()">
                    ‚ö° Optimize All
                </button>
                <button class="btn btn-danger" onclick="worldBuilder.validateWorld()">
                    ‚úÖ Validate World
                </button>
                <button class="btn btn-primary" onclick="worldBuilder.toggleAdvanced()">
                    üîß Advanced Mode
                </button>
            </div>

            <!-- Debug Controls -->
            <div class="section">
                <div class="section-title">üî¨ Debug & Performance</div>
                <button class="btn btn-danger" onclick="worldBuilder.toggleDebugPanel()">
                    üêõ Debug Console (F12)
                </button>
                <button class="btn btn-warning" onclick="worldBuilder.togglePerformanceMonitor()">
                    üìä Performance (Ctrl+Shift+P)
                </button>
                <button class="btn btn-primary" onclick="worldBuilder.runTests()">
                    üß™ Run Tests
                </button>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area">
            <canvas id="worldCanvas"></canvas>
            
            <!-- Status Bar -->
            <div class="status-bar">
                <div id="mouseInfo">Mouse: (0, 0) | World: (0, 0)</div>
                <div id="toolInfo">Tool: Select | Mode: Normal</div>
                <div id="performanceInfo">FPS: 60 | Memory: 0MB | Objects: 0</div>
            </div>

            <!-- Debug Panel -->
            <div class="debug-panel" id="debugPanel">
                <div class="debug-header">
                    üêõ Advanced Debug Console
                    <span class="debug-close" onclick="worldBuilder.toggleDebugPanel()">‚úï</span>
                </div>
                <div id="debugOutput">Debug console initialized...\n</div>
            </div>

            <!-- Performance Monitor -->
            <div class="performance-monitor" id="performanceMonitor">
                <div><strong>üìä Performance Monitor</strong></div>
                <div id="fpsDisplay">FPS: --</div>
                <div id="memoryDisplay">Memory: --</div>
                <div id="renderTimeDisplay">Render: --ms</div>
                <div id="objectCountDisplay">Objects: --</div>
            </div>
        </div>

        <!-- Right Panel: Island Properties -->
        <div class="right-panel">
            <div class="header">
                <h1>üèùÔ∏è Island Properties</h1>
            </div>

            <!-- Island Selection -->
            <div class="section">
                <div class="section-title">üìã Island Selection</div>
                <div class="input-group">
                    <label>Select Island:</label>
                    <select id="islandSelector" onchange="worldBuilder.selectIslandById(this.value)">
                        <option value="">-- No islands loaded --</option>
                    </select>
                </div>
                <div class="island-list" id="islandList">
                    <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                        No islands loaded. Click "Load from Server" to begin.
                    </div>
                </div>
            </div>

            <!-- Island Properties -->
            <div class="section" id="islandPropsSection" style="display: none;">
                <div class="section-title">‚öôÔ∏è Properties</div>
                
                <div class="input-group">
                    <label>Name:</label>
                    <input type="text" id="islandName" placeholder="Island Name" onchange="worldBuilder.updateSelectedIsland()">
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div class="input-group">
                        <label>X Position:</label>
                        <input type="number" id="islandX" placeholder="X" onchange="worldBuilder.updateSelectedIsland()">
                    </div>
                    <div class="input-group">
                        <label>Y Position:</label>
                        <input type="number" id="islandY" placeholder="Y" onchange="worldBuilder.updateSelectedIsland()">
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div class="input-group">
                        <label>Width:</label>
                        <input type="number" id="islandWidth" placeholder="Width" onchange="worldBuilder.updateSelectedIsland()">
                    </div>
                    <div class="input-group">
                        <label>Height:</label>
                        <input type="number" id="islandHeight" placeholder="Height" onchange="worldBuilder.updateSelectedIsland()">
                    </div>
                </div>
                
                <div class="input-group">
                    <label>Radius:</label>
                    <input type="number" id="islandRadius" placeholder="Radius" onchange="worldBuilder.updateSelectedIsland()">
                </div>
                
                <div class="input-group">
                    <label>Rotation:</label>
                    <input type="range" id="islandRotation" min="0" max="360" value="0" 
                           onchange="worldBuilder.updateSelectedIsland(); document.getElementById('rotationValue').textContent = this.value + '¬∞'">
                    <div style="text-align: center; font-size: 11px; color: #7f8c8d;">
                        <span id="rotationValue">0¬∞</span>
                    </div>
                </div>
                
                <button class="btn btn-primary" onclick="worldBuilder.updateSelectedIsland()">
                    üíæ Update Island
                </button>
                <button class="btn btn-danger" onclick="worldBuilder.deleteSelectedIsland()">
                    üóëÔ∏è Delete Island
                </button>
            </div>

            <!-- Collision Editor -->
            <div class="section" id="collisionSection" style="display: none;">
                <div class="section-title">üí• Collision Editor</div>
                
                <div class="tool-palette">
                    <button class="btn btn-success" onclick="worldBuilder.startLineDrawing()">
                        ‚úèÔ∏è Draw Line
                    </button>
                    <button class="btn btn-warning" onclick="worldBuilder.optimizeCollision()">
                        ‚ö° Optimize
                    </button>
                    <button class="btn btn-danger" onclick="worldBuilder.clearCollision()">
                        üóëÔ∏è Clear All
                    </button>
                    <button class="btn btn-primary" onclick="worldBuilder.autoTrace()">
                        üñäÔ∏è Auto Trace
                    </button>
                </div>
                
                <div class="collision-info" id="collisionInfo">
                    <div>Collision Points: 0</div>
                    <div>Area: 0 sq units</div>
                    <div>Status: No collision data</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AdvancedWorldBuilder {
            constructor() {
                this.version = '2.1.0';
                this.canvas = document.getElementById('worldCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // World configuration
                this.worldWidth = 10240;
                this.worldHeight = 7680;
                this.gridSize = 100;
                this.showGrid = true;
                
                // Viewport
                this.zoom = 0.08;
                this.offsetX = 0;
                this.offsetY = 0;
                this.minZoom = 0.02;
                this.maxZoom = 3.0;
                
                // State
                this.islands = [];
                this.selectedIsland = null;
                this.currentTool = 'select';
                this.isLineDrawing = false;
                this.tempLinePoints = [];
                
                // Performance monitoring
                this.performanceData = {
                    fps: 0,
                    frameCount: 0,
                    lastTime: 0,
                    renderTime: 0,
                    memoryUsage: 0
                };
                
                // Debug system
                this.debugEnabled = false;
                this.debugOutput = [];
                
                // Mouse state
                this.mouse = {
                    x: 0, y: 0,
                    worldX: 0, worldY: 0,
                    isDown: false,
                    isDragging: false,
                    lastX: 0, lastY: 0
                };
                
                this.init();
            }
            
            init() {
                this.log('üåä GORET Advanced World Builder v' + this.version + ' initializing...');
                this.setupCanvas();
                this.setupEventListeners();
                this.startRenderLoop();
                this.updateUI();
                this.log('‚úÖ World Builder ready for use!');
            }
            
            setupCanvas() {
                const container = this.canvas.parentElement;
                this.resizeCanvas();
                
                // Auto-resize handler
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.render();
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Keyboard events
                window.addEventListener('keydown', (e) => this.onKeyDown(e));
                
                // Prevent context menu
                this.canvas.oncontextmenu = (e) => e.preventDefault();
            }
            
            onMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = e.clientX - rect.left;
                this.mouse.y = e.clientY - rect.top;
                this.mouse.isDown = true;
                this.mouse.lastX = this.mouse.x;
                this.mouse.lastY = this.mouse.y;
                
                this.updateWorldMouse();
                
                if (e.button === 2) { // Right click
                    this.onRightClick(e);
                    return;
                }
                
                // Handle tool-specific actions
                switch (this.currentTool) {
                    case 'select':
                        this.handleSelectClick();
                        break;
                    case 'addIsland':
                        this.handleAddIslandClick();
                        break;
                    case 'line':
                        this.handleLineClick();
                        break;
                    case 'editCollision':
                        this.handleCollisionClick();
                        break;
                }
                
                this.render();
            }
            
            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = e.clientX - rect.left;
                this.mouse.y = e.clientY - rect.top;
                
                this.updateWorldMouse();
                
                // Handle panning in select mode
                if (this.mouse.isDown && this.currentTool === 'select' && !this.getIslandAtMouse()) {
                    this.mouse.isDragging = true;
                    const deltaX = this.mouse.x - this.mouse.lastX;
                    const deltaY = this.mouse.y - this.mouse.lastY;
                    
                    this.offsetX -= deltaX / this.zoom;
                    this.offsetY -= deltaY / this.zoom;
                    
                    this.render();
                }
                
                this.mouse.lastX = this.mouse.x;
                this.mouse.lastY = this.mouse.y;
                this.updateStatusBar();
            }
            
            onMouseUp(e) {
                this.mouse.isDown = false;
                this.mouse.isDragging = false;
            }
            
            onRightClick(e) {
                if (this.currentTool === 'line' && this.isLineDrawing) {
                    this.finishLineDrawing();
                }
            }
            
            onWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Zoom towards mouse
                const worldMouseX = (mouseX / this.zoom) + this.offsetX;
                const worldMouseY = (mouseY / this.zoom) + this.offsetY;
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom * zoomFactor));
                
                this.offsetX = worldMouseX - (mouseX / newZoom);
                this.offsetY = worldMouseY - (mouseY / newZoom);
                this.zoom = newZoom;
                
                this.render();
                this.updateStatusBar();
            }
            
            onKeyDown(e) {
                switch (e.code) {
                    case 'KeyG':
                        e.preventDefault();
                        this.toggleGrid();
                        break;
                    case 'KeyF':
                        e.preventDefault();
                        this.fitWorld();
                        break;
                    case 'KeyR':
                        e.preventDefault();
                        this.resetView();
                        break;
                    case 'F12':
                        e.preventDefault();
                        this.toggleDebugPanel();
                        break;
                    case 'Escape':
                        e.preventDefault();
                        if (this.isLineDrawing) {
                            this.cancelLineDrawing();
                        }
                        break;
                    case 'Delete':
                        if (this.selectedIsland) {
                            this.deleteSelectedIsland();
                        }
                        break;
                }
                
                // Advanced shortcuts
                if (e.ctrlKey && e.shiftKey) {
                    switch (e.code) {
                        case 'KeyP':
                            e.preventDefault();
                            this.togglePerformanceMonitor();
                            break;
                        case 'KeyV':
                            e.preventDefault();
                            this.validateWorld();
                            break;
                    }
                }
            }
            
            updateWorldMouse() {
                this.mouse.worldX = (this.mouse.x / this.zoom) + this.offsetX;
                this.mouse.worldY = (this.mouse.y / this.zoom) + this.offsetY;
            }
            
            // Tool Management
            setTool(tool) {
                // Reset current tool state
                if (this.isLineDrawing) {
                    this.cancelLineDrawing();
                }
                
                // Update tool
                this.currentTool = tool;
                
                // Update UI
                document.querySelectorAll('.tool-palette .btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                const toolButton = document.getElementById(tool + 'Tool');
                if (toolButton) {
                    toolButton.classList.add('active');
                }
                
                // Update cursor
                this.updateCursor();
                this.updateStatusBar();
                this.log(`Tool changed to: ${tool}`);
            }
            
            updateCursor() {
                const cursors = {
                    select: 'default',
                    addIsland: 'crosshair',
                    line: 'crosshair',
                    editCollision: 'pointer'
                };
                
                this.canvas.style.cursor = cursors[this.currentTool] || 'default';
            }
            
            // Island Management
            handleSelectClick() {
                const island = this.getIslandAtMouse();
                this.selectIsland(island);
            }
            
            handleAddIslandClick() {
                const newIsland = {
                    name: `Island ${this.islands.length + 1}`,
                    x: this.mouse.worldX,
                    y: this.mouse.worldY,
                    width: 200,
                    height: 200,
                    radius: 100,
                    rotation: 0,
                    collision: [],
                    image: null,
                    originalImageData: null,
                    isExisting: false
                };
                
                this.islands.push(newIsland);
                this.selectIsland(newIsland);
                this.updateIslandsList();
                this.log(`Added new island: ${newIsland.name} at (${Math.round(newIsland.x)}, ${Math.round(newIsland.y)})`);
            }
            
            handleLineClick() {
                if (!this.selectedIsland) {
                    this.log('‚ö†Ô∏è Please select an island first before drawing collision lines');
                    return;
                }
                
                if (!this.isLineDrawing) {
                    this.startLineDrawing();
                } else {
                    this.addPointToLine();
                }
            }
            
            handleCollisionClick() {
                // Handle collision point editing
                this.handleLineClick();
            }
            
            getIslandAtMouse() {
                for (let island of this.islands) {
                    const dx = this.mouse.worldX - island.x;
                    const dy = this.mouse.worldY - island.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= island.radius) {
                        return island;
                    }
                }
                return null;
            }
            
            selectIsland(island) {
                this.selectedIsland = island;
                
                if (island) {
                    this.updateIslandProperties();
                    document.getElementById('islandPropsSection').style.display = 'block';
                    document.getElementById('collisionSection').style.display = 'block';
                    this.log(`Selected island: ${island.name}`);
                } else {
                    document.getElementById('islandPropsSection').style.display = 'none';
                    document.getElementById('collisionSection').style.display = 'none';
                }
                
                this.updateIslandsList();
                this.updateCollisionInfo();
                this.render();
            }
            
            selectIslandById(index) {
                if (index === '') {
                    this.selectIsland(null);
                } else {
                    this.selectIsland(this.islands[parseInt(index)]);
                }
            }
            
            updateIslandProperties() {
                if (!this.selectedIsland) return;
                
                document.getElementById('islandName').value = this.selectedIsland.name || '';
                document.getElementById('islandX').value = Math.round(this.selectedIsland.x);
                document.getElementById('islandY').value = Math.round(this.selectedIsland.y);
                document.getElementById('islandWidth').value = this.selectedIsland.width || 200;
                document.getElementById('islandHeight').value = this.selectedIsland.height || 200;
                document.getElementById('islandRadius').value = this.selectedIsland.radius || 100;
                document.getElementById('islandRotation').value = this.selectedIsland.rotation || 0;
                document.getElementById('rotationValue').textContent = (this.selectedIsland.rotation || 0) + '¬∞';
            }
            
            updateSelectedIsland() {
                if (!this.selectedIsland) return;
                
                this.selectedIsland.name = document.getElementById('islandName').value;
                this.selectedIsland.x = parseFloat(document.getElementById('islandX').value) || 0;
                this.selectedIsland.y = parseFloat(document.getElementById('islandY').value) || 0;
                this.selectedIsland.width = parseFloat(document.getElementById('islandWidth').value) || 200;
                this.selectedIsland.height = parseFloat(document.getElementById('islandHeight').value) || 200;
                this.selectedIsland.radius = parseFloat(document.getElementById('islandRadius').value) || 100;
                this.selectedIsland.rotation = parseFloat(document.getElementById('islandRotation').value) || 0;
                
                this.updateIslandsList();
                this.render();
                this.log(`Updated island: ${this.selectedIsland.name}`);
            }
            
            deleteSelectedIsland() {
                if (!this.selectedIsland) return;
                
                const islandName = this.selectedIsland.name;
                const index = this.islands.indexOf(this.selectedIsland);
                
                if (confirm(`Delete island "${islandName}"? This cannot be undone.`)) {
                    this.islands.splice(index, 1);
                    this.selectIsland(null);
                    this.updateIslandsList();
                    this.render();
                    this.log(`Deleted island: ${islandName}`);
                }
            }
            
            // Line Drawing System
            startLineDrawing() {
                if (!this.selectedIsland) {
                    this.log('‚ö†Ô∏è Please select an island first');
                    return;
                }
                
                this.isLineDrawing = true;
                this.tempLinePoints = [];
                this.selectedIsland.collision = [];
                this.log('Started collision line drawing. Click to add points, right-click to finish.');
                this.updateCollisionInfo();
            }
            
            addPointToLine() {
                if (!this.isLineDrawing) return;
                
                // Convert world coordinates to relative coordinates
                const relativeX = this.mouse.worldX - this.selectedIsland.x;
                const relativeY = this.mouse.worldY - this.selectedIsland.y;
                
                const point = {
                    x: Math.round(this.mouse.worldX * 10) / 10, // World coordinates for compatibility
                    y: Math.round(this.mouse.worldY * 10) / 10
                };
                
                this.selectedIsland.collision.push(point);
                this.tempLinePoints.push(point);
                
                this.log(`Added collision point: (${point.x}, ${point.y})`);
                this.updateCollisionInfo();
                this.render();
            }
            
            finishLineDrawing() {
                if (!this.isLineDrawing) return;
                
                this.isLineDrawing = false;
                this.tempLinePoints = [];
                
                if (this.selectedIsland.collision.length > 2) {
                    this.log(`Finished collision line with ${this.selectedIsland.collision.length} points`);
                } else {
                    this.selectedIsland.collision = [];
                    this.log('‚ö†Ô∏è Collision line cancelled - need at least 3 points');
                }
                
                this.updateCollisionInfo();
                this.render();
            }
            
            cancelLineDrawing() {
                this.isLineDrawing = false;
                this.tempLinePoints = [];
                
                if (this.selectedIsland) {
                    this.selectedIsland.collision = [];
                }
                
                this.log('Collision line drawing cancelled');
                this.updateCollisionInfo();
                this.render();
            }
            
            // Server Communication
            async loadFromServer() {
                try {
                    this.log('üì• Loading islands from server...');
                    const response = await fetch('http://localhost:8001/api/islands/load');
                    
                    if (!response.ok) {
                        throw new Error(`Server responded with ${response.status}`);
                    }
                    
                    const data = await response.json();
                    this.islands = data.islands || [];
                    
                    this.log(`‚úÖ Loaded ${this.islands.length} islands from server`);
                    this.updateIslandsList();
                    this.fitWorld();
                    
                } catch (error) {
                    this.log(`‚ùå Failed to load from server: ${error.message}`);
                    // Load default data as fallback
                    this.loadDefaultData();
                }
            }
            
            async saveToServer() {
                try {
                    this.log('üíæ Saving islands to server...');
                    
                    const data = {
                        islands: this.islands,
                        worldWidth: this.worldWidth,
                        worldHeight: this.worldHeight
                    };
                    
                    const response = await fetch('http://localhost:8001/api/islands/save', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Server responded with ${response.status}`);
                    }
                    
                    const result = await response.json();
                    this.log(`‚úÖ Successfully saved ${this.islands.length} islands to server`);
                    
                } catch (error) {
                    this.log(`‚ùå Failed to save to server: ${error.message}`);
                    // Fallback to local JSON export
                    this.exportJSON();
                }
            }
            
            loadDefaultData() {
                // Load the exact same data as the compatibility document specifies
                this.islands = [
                    {
                        name: 'Saint Kitts',
                        x: 1810,
                        y: 1655,
                        width: 1030,
                        height: 1063,
                        radius: 289,
                        rotation: 0,
                        image: null,
                        originalImageData: null,
                        isExisting: true,
                        collision: [
                            { x: 1608.8, y: 1123.6 },
                            { x: 1544.7, y: 1174.4 },
                            { x: 1520.1, y: 1235.8 },
                            { x: 1505.6, y: 1308.5 },
                            { x: 1520.1, y: 1379.7 },
                            { x: 1554.2, y: 1439.6 },
                            { x: 1603.3, y: 1489.2 },
                            { x: 1664.7, y: 1525.3 },
                            { x: 1734.4, y: 1546.4 },
                            { x: 1808.6, y: 1551.9 },
                            { x: 1883.3, y: 1540.9 },
                            { x: 1954.5, y: 1514.8 },
                            { x: 2018.6, y: 1475.7 },
                            { x: 2072.7, y: 1426.6 },
                            { x: 2114.3, y: 1370.2 },
                            { x: 2141.9, y: 1308.5 },
                            { x: 2154.4, y: 1244.3 },
                            { x: 2150.9, y: 1179.9 },
                            { x: 2131.3, y: 1118.1 },
                            { x: 2096.7, y: 1060.2 },
                            { x: 2048.6, y: 1008.1 },
                            { x: 1989.2, y: 964.7 },
                            { x: 1921.7, y: 932.6 },
                            { x: 1848.5, y: 914.5 },
                            { x: 1773.8, y: 912.0 },
                            { x: 1701.1, y: 926.1 },
                            { x: 1633.6, y: 957.2 },
                            { x: 1574.2, y: 1003.6 },
                            { x: 1526.6, y: 1063.2 }
                        ]
                    },
                    {
                        name: 'Nevis',
                        x: 2500,
                        y: 2800,
                        width: 600,
                        height: 600,
                        radius: 180,
                        rotation: 0,
                        image: null,
                        originalImageData: null,
                        isExisting: true,
                        collision: [
                            { x: 2380.5, y: 2665.2 },
                            { x: 2340.8, y: 2720.4 },
                            { x: 2325.1, y: 2785.6 },
                            { x: 2335.4, y: 2851.8 },
                            { x: 2370.2, y: 2909.3 },
                            { x: 2425.4, y: 2949.0 },
                            { x: 2490.6, y: 2964.7 },
                            { x: 2556.8, y: 2954.4 },
                            { x: 2614.3, y: 2919.6 },
                            { x: 2654.0, y: 2864.4 },
                            { x: 2669.7, y: 2799.2 },
                            { x: 2659.4, y: 2733.0 },
                            { x: 2624.6, y: 2675.5 },
                            { x: 2569.4, y: 2635.8 },
                            { x: 2504.2, y: 2620.1 },
                            { x: 2438.0, y: 2630.4 }
                        ]
                    }
                ];
                
                this.log('üì¶ Loaded default island data (Saint Kitts & Nevis)');
                this.updateIslandsList();
                this.fitWorld();
            }
            
            // View Controls
            toggleGrid() {
                this.showGrid = !this.showGrid;
                document.getElementById('gridToggleText').textContent = this.showGrid ? 'Hide Grid' : 'Show Grid';
                this.render();
                this.log(`Grid ${this.showGrid ? 'enabled' : 'disabled'}`);
            }
            
            setGridSize(size) {
                this.gridSize = parseInt(size);
                document.getElementById('gridSizeValue').textContent = size + 'px';
                this.render();
            }
            
            fitWorld() {
                const padding = 100;
                const scaleX = (this.canvas.width - padding * 2) / this.worldWidth;
                const scaleY = (this.canvas.height - padding * 2) / this.worldHeight;
                
                this.zoom = Math.min(scaleX, scaleY);
                this.offsetX = (this.worldWidth - this.canvas.width / this.zoom) / 2;
                this.offsetY = (this.worldHeight - this.canvas.height / this.zoom) / 2;
                
                this.render();
                this.log('üéØ Fitted world to view');
            }
            
            resetView() {
                this.zoom = 0.08;
                this.offsetX = 0;
                this.offsetY = 0;
                this.render();
                this.log('üîÑ Reset view to default');
            }
            
            // Advanced Features
            optimizeAll() {
                let optimizedCount = 0;
                
                this.islands.forEach(island => {
                    if (island.collision && island.collision.length > 3) {
                        const originalCount = island.collision.length;
                        island.collision = this.optimizeCollisionPoints(island.collision);
                        if (island.collision.length < originalCount) {
                            optimizedCount++;
                        }
                    }
                });
                
                this.render();
                this.updateCollisionInfo();
                this.log(`‚ö° Optimized ${optimizedCount} islands`);
            }
            
            optimizeCollisionPoints(points) {
                if (points.length <= 3) return points;
                
                const tolerance = 5; // Tolerance for point reduction
                const optimized = [points[0]]; // Always keep first point
                
                for (let i = 1; i < points.length - 1; i++) {
                    const prev = optimized[optimized.length - 1];
                    const current = points[i];
                    const next = points[i + 1];
                    
                    // Calculate if current point is necessary
                    const distance = this.pointToLineDistance(current, prev, next);
                    
                    if (distance > tolerance) {
                        optimized.push(current);
                    }
                }
                
                optimized.push(points[points.length - 1]); // Always keep last point
                return optimized;
            }
            
            pointToLineDistance(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            validateWorld() {
                const issues = [];
                
                // Check for overlapping islands
                for (let i = 0; i < this.islands.length; i++) {
                    for (let j = i + 1; j < this.islands.length; j++) {
                        const island1 = this.islands[i];
                        const island2 = this.islands[j];
                        
                        const dx = island1.x - island2.x;
                        const dy = island1.y - island2.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = island1.radius + island2.radius;
                        
                        if (distance < minDistance) {
                            issues.push(`Islands "${island1.name}" and "${island2.name}" are overlapping`);
                        }
                    }
                }
                
                // Check for islands without collision data
                this.islands.forEach(island => {
                    if (!island.collision || island.collision.length === 0) {
                        issues.push(`Island "${island.name}" has no collision data`);
                    }
                });
                
                // Check for islands outside world bounds
                this.islands.forEach(island => {
                    if (island.x < 0 || island.x > this.worldWidth || 
                        island.y < 0 || island.y > this.worldHeight) {
                        issues.push(`Island "${island.name}" is outside world bounds`);
                    }
                });
                
                if (issues.length === 0) {
                    this.log('‚úÖ World validation passed - no issues found');
                    alert('‚úÖ World validation passed!\n\nNo issues detected.');
                } else {
                    this.log(`‚ö†Ô∏è World validation found ${issues.length} issues:`);
                    issues.forEach(issue => this.log(`  - ${issue}`));
                    
                    alert(`‚ö†Ô∏è World validation found ${issues.length} issues:\n\n` + 
                          issues.map(issue => `‚Ä¢ ${issue}`).join('\n'));
                }
            }
            
            // Data Management
            importJSON() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            this.islands = data.islands || data || [];
                            this.updateIslandsList();
                            this.fitWorld();
                            this.log(`üìÇ Imported ${this.islands.length} islands from JSON`);
                        } catch (error) {
                            this.log(`‚ùå Failed to import JSON: ${error.message}`);
                            alert('‚ùå Failed to import JSON file. Please check the file format.');
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            }
            
            exportJSON() {
                const data = {
                    worldWidth: this.worldWidth,
                    worldHeight: this.worldHeight,
                    islands: this.islands,
                    exportedAt: new Date().toISOString(),
                    version: this.version
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `goret-world-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.log(`üì§ Exported world data to JSON (${this.islands.length} islands)`);
            }
            
            // Debug System
            toggleDebugPanel() {
                const panel = document.getElementById('debugPanel');
                this.debugEnabled = !this.debugEnabled;
                panel.style.display = this.debugEnabled ? 'block' : 'none';
                
                if (this.debugEnabled) {
                    this.log('üêõ Debug console enabled');
                } else {
                    this.log('üêõ Debug console disabled');
                }
            }
            
            togglePerformanceMonitor() {
                const monitor = document.getElementById('performanceMonitor');
                monitor.style.display = monitor.style.display === 'none' ? 'block' : 'none';
                this.log('üìä Performance monitor toggled');
            }
            
            toggleAdvanced() {
                const advancedElements = document.querySelectorAll('.advanced-controls');
                advancedElements.forEach(el => el.classList.toggle('active'));
                this.log('üîß Advanced mode toggled');
            }
            
            runTests() {
                this.log('üß™ Running automated tests...');
                
                const tests = [
                    () => this.testCanvasRendering(),
                    () => this.testIslandCreation(),
                    () => this.testCollisionDetection(),
                    () => this.testDataSerialization(),
                    () => this.testPerformance()
                ];
                
                let passed = 0;
                let total = tests.length;
                
                tests.forEach((test, index) => {
                    try {
                        if (test()) {
                            passed++;
                            this.log(`‚úÖ Test ${index + 1}/${total} passed`);
                        } else {
                            this.log(`‚ùå Test ${index + 1}/${total} failed`);
                        }
                    } catch (error) {
                        this.log(`‚ùå Test ${index + 1}/${total} error: ${error.message}`);
                    }
                });
                
                this.log(`üß™ Tests completed: ${passed}/${total} passed`);
                
                if (passed === total) {
                    alert(`‚úÖ All tests passed!\n\n${passed}/${total} tests successful.`);
                } else {
                    alert(`‚ö†Ô∏è Some tests failed.\n\n${passed}/${total} tests passed.\n\nCheck debug console for details.`);
                }
            }
            
            testCanvasRendering() {
                return this.canvas && this.ctx && this.canvas.width > 0 && this.canvas.height > 0;
            }
            
            testIslandCreation() {
                const initialCount = this.islands.length;
                const testIsland = {
                    name: 'Test Island',
                    x: 1000, y: 1000,
                    radius: 100,
                    collision: []
                };
                
                this.islands.push(testIsland);
                const success = this.islands.length === initialCount + 1;
                
                // Clean up
                this.islands.splice(-1, 1);
                
                return success;
            }
            
            testCollisionDetection() {
                // Test point-in-circle collision
                const testPoint = { x: 100, y: 100 };
                const testIsland = { x: 100, y: 100, radius: 50 };
                
                const dx = testPoint.x - testIsland.x;
                const dy = testPoint.y - testIsland.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance <= testIsland.radius;
            }
            
            testDataSerialization() {
                try {
                    const testData = { islands: this.islands };
                    const serialized = JSON.stringify(testData);
                    const parsed = JSON.parse(serialized);
                    return Array.isArray(parsed.islands);
                } catch {
                    return false;
                }
            }
            
            testPerformance() {
                const startTime = performance.now();
                
                // Simulate some work
                for (let i = 0; i < 1000; i++) {
                    Math.sqrt(i * Math.random());
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                
                return duration < 100; // Should complete in under 100ms
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                
                console.log(logEntry);
                this.debugOutput.push(logEntry);
                
                // Update debug panel
                const debugOutput = document.getElementById('debugOutput');
                if (debugOutput) {
                    debugOutput.textContent = this.debugOutput.slice(-50).join('\n');
                    debugOutput.scrollTop = debugOutput.scrollHeight;
                }
            }
            
            // UI Updates
            updateStatusBar() {
                document.getElementById('mouseInfo').textContent = 
                    `Mouse: (${Math.round(this.mouse.x)}, ${Math.round(this.mouse.y)}) | ` +
                    `World: (${Math.round(this.mouse.worldX)}, ${Math.round(this.mouse.worldY)})`;
                
                document.getElementById('toolInfo').textContent = 
                    `Tool: ${this.currentTool} | Mode: ${this.isLineDrawing ? 'Line Drawing' : 'Normal'}`;
                
                document.getElementById('performanceInfo').textContent = 
                    `FPS: ${this.performanceData.fps} | ` +
                    `Memory: ${this.performanceData.memoryUsage}MB | ` +
                    `Objects: ${this.islands.length}`;
            }
            
            updateIslandsList() {
                const selector = document.getElementById('islandSelector');
                const list = document.getElementById('islandList');
                
                // Update selector
                selector.innerHTML = '<option value="">-- Select Island --</option>';
                
                if (this.islands.length === 0) {
                    list.innerHTML = '<div style="text-align: center; color: #7f8c8d; padding: 20px;">No islands loaded. Click "Load from Server" to begin.</div>';
                    return;
                }
                
                // Update selector and list
                let listHTML = '';
                
                this.islands.forEach((island, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${island.name} (${island.collision ? island.collision.length : 0} points)`;
                    selector.appendChild(option);
                    
                    const isSelected = island === this.selectedIsland;
                    listHTML += `
                        <div class="island-item ${isSelected ? 'selected' : ''}" onclick="worldBuilder.selectIslandById('${index}')">
                            <div style="font-weight: bold;">${island.name}</div>
                            <div style="font-size: 10px; color: #7f8c8d;">
                                Position: (${Math.round(island.x)}, ${Math.round(island.y)}) | 
                                Radius: ${island.radius} | 
                                Points: ${island.collision ? island.collision.length : 0}
                            </div>
                        </div>
                    `;
                });
                
                list.innerHTML = listHTML;
                
                // Update selector to match selected island
                if (this.selectedIsland) {
                    const index = this.islands.indexOf(this.selectedIsland);
                    if (index !== -1) {
                        selector.value = index;
                    }
                }
            }
            
            updateCollisionInfo() {
                const info = document.getElementById('collisionInfo');
                
                if (!this.selectedIsland) {
                    info.innerHTML = `
                        <div>Collision Points: 0</div>
                        <div>Area: 0 sq units</div>
                        <div>Status: No island selected</div>
                    `;
                    return;
                }
                
                const pointCount = this.selectedIsland.collision ? this.selectedIsland.collision.length : 0;
                const area = this.calculateCollisionArea(this.selectedIsland.collision || []);
                const status = pointCount === 0 ? 'No collision data' : 
                              pointCount < 3 ? 'Incomplete (need 3+ points)' : 
                              'Valid collision shape';
                
                info.innerHTML = `
                    <div>Collision Points: ${pointCount}</div>
                    <div>Area: ${Math.round(area)} sq units</div>
                    <div>Status: ${status}</div>
                    ${this.isLineDrawing ? '<div style="color: #f39c12;">üñäÔ∏è Drawing mode active</div>' : ''}
                `;
            }
            
            calculateCollisionArea(points) {
                if (points.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < points.length; i++) {
                    const j = (i + 1) % points.length;
                    area += points[i].x * points[j].y;
                    area -= points[j].x * points[i].y;
                }
                return Math.abs(area / 2);
            }
            
            updateUI() {
                this.updateStatusBar();
                this.updateIslandsList();
                this.updateCollisionInfo();
            }
            
            // Performance Monitoring
            updatePerformanceData() {
                const now = performance.now();
                
                if (this.performanceData.lastTime === 0) {
                    this.performanceData.lastTime = now;
                    return;
                }
                
                const deltaTime = now - this.performanceData.lastTime;
                this.performanceData.frameCount++;
                
                if (deltaTime >= 1000) {
                    this.performanceData.fps = Math.round(this.performanceData.frameCount * 1000 / deltaTime);
                    this.performanceData.frameCount = 0;
                    this.performanceData.lastTime = now;
                    
                    // Estimate memory usage
                    if (performance.memory) {
                        this.performanceData.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    }
                    
                    // Update performance monitor display
                    const monitor = document.getElementById('performanceMonitor');
                    if (monitor && monitor.style.display !== 'none') {
                        document.getElementById('fpsDisplay').textContent = `FPS: ${this.performanceData.fps}`;
                        document.getElementById('memoryDisplay').textContent = `Memory: ${this.performanceData.memoryUsage}MB`;
                        document.getElementById('renderTimeDisplay').textContent = `Render: ${this.performanceData.renderTime.toFixed(2)}ms`;
                        document.getElementById('objectCountDisplay').textContent = `Objects: ${this.islands.length}`;
                    }
                }
            }
            
            // Rendering System
            startRenderLoop() {
                const renderFrame = () => {
                    const startTime = performance.now();
                    
                    this.render();
                    this.updatePerformanceData();
                    
                    const endTime = performance.now();
                    this.performanceData.renderTime = endTime - startTime;
                    
                    requestAnimationFrame(renderFrame);
                };
                
                renderFrame();
            }
            
            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Fill ocean background
                this.ctx.fillStyle = '#1e3a5f';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply world transformations
                this.ctx.save();
                this.ctx.scale(this.zoom, this.zoom);
                this.ctx.translate(-this.offsetX, -this.offsetY);
                
                // Draw grid
                if (this.showGrid) {
                    this.drawGrid();
                }
                
                // Draw world boundaries
                this.drawWorldBounds();
                
                // Draw islands
                this.drawIslands();
                
                // Draw temporary line (if line drawing)
                if (this.isLineDrawing) {
                    this.drawTempLine();
                }
                
                this.ctx.restore();
            }
            
            drawGrid() {
                const startX = Math.floor(this.offsetX / this.gridSize) * this.gridSize;
                const endX = startX + (this.canvas.width / this.zoom) + this.gridSize;
                const startY = Math.floor(this.offsetY / this.gridSize) * this.gridSize;
                const endY = startY + (this.canvas.height / this.zoom) + this.gridSize;
                
                // Minor grid lines
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
                this.ctx.lineWidth = 1 / this.zoom;
                this.ctx.beginPath();
                
                for (let x = startX; x <= endX; x += this.gridSize) {
                    if (x >= 0 && x <= this.worldWidth) {
                        this.ctx.moveTo(x, Math.max(0, this.offsetY));
                        this.ctx.lineTo(x, Math.min(this.worldHeight, this.offsetY + this.canvas.height / this.zoom));
                    }
                }
                
                for (let y = startY; y <= endY; y += this.gridSize) {
                    if (y >= 0 && y <= this.worldHeight) {
                        this.ctx.moveTo(Math.max(0, this.offsetX), y);
                        this.ctx.lineTo(Math.min(this.worldWidth, this.offsetX + this.canvas.width / this.zoom), y);
                    }
                }
                
                this.ctx.stroke();
                
                // Major grid lines (every 5 units)
                const majorSize = this.gridSize * 5;
                const majorStartX = Math.floor(this.offsetX / majorSize) * majorSize;
                const majorEndX = majorStartX + (this.canvas.width / this.zoom) + majorSize;
                const majorStartY = Math.floor(this.offsetY / majorSize) * majorSize;
                const majorEndY = majorStartY + (this.canvas.height / this.zoom) + majorSize;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.25)';
                this.ctx.lineWidth = 2 / this.zoom;
                this.ctx.beginPath();
                
                for (let x = majorStartX; x <= majorEndX; x += majorSize) {
                    if (x >= 0 && x <= this.worldWidth) {
                        this.ctx.moveTo(x, Math.max(0, this.offsetY));
                        this.ctx.lineTo(x, Math.min(this.worldHeight, this.offsetY + this.canvas.height / this.zoom));
                    }
                }
                
                for (let y = majorStartY; y <= majorEndY; y += majorSize) {
                    if (y >= 0 && y <= this.worldHeight) {
                        this.ctx.moveTo(Math.max(0, this.offsetX), y);
                        this.ctx.lineTo(Math.min(this.worldWidth, this.offsetX + this.canvas.width / this.zoom), y);
                    }
                }
                
                this.ctx.stroke();
            }
            
            drawWorldBounds() {
                this.ctx.strokeStyle = '#ff6b6b';
                this.ctx.lineWidth = 4 / this.zoom;
                this.ctx.strokeRect(0, 0, this.worldWidth, this.worldHeight);
                
                // Draw world size label
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.font = `${20 / this.zoom}px Arial`;
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`${this.worldWidth} √ó ${this.worldHeight}`, 20, 40 / this.zoom);
            }
            
            drawIslands() {
                for (let island of this.islands) {
                    this.drawIsland(island);
                }
            }
            
            drawIsland(island) {
                const isSelected = island === this.selectedIsland;
                
                // Draw island circle
                this.ctx.strokeStyle = isSelected ? '#ff4757' : '#2ed573';
                this.ctx.fillStyle = isSelected ? 'rgba(255, 71, 87, 0.1)' : 'rgba(46, 213, 115, 0.1)';
                this.ctx.lineWidth = 3 / this.zoom;
                
                this.ctx.beginPath();
                this.ctx.arc(island.x, island.y, island.radius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();
                
                // Draw island name
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = `bold ${16 / this.zoom}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Background for text
                const textMetrics = this.ctx.measureText(island.name);
                const textWidth = textMetrics.width;
                const textHeight = 16 / this.zoom;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(
                    island.x - textWidth / 2 - 5 / this.zoom,
                    island.y - island.radius - textHeight - 10 / this.zoom,
                    textWidth + 10 / this.zoom,
                    textHeight + 8 / this.zoom
                );
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillText(island.name, island.x, island.y - island.radius - 10 / this.zoom);
                
                // Draw collision outline
                if (island.collision && island.collision.length > 2) {
                    this.ctx.strokeStyle = isSelected ? '#ffa502' : '#70a1ff';
                    this.ctx.lineWidth = 2 / this.zoom;
                    this.ctx.beginPath();
                    
                    for (let i = 0; i < island.collision.length; i++) {
                        const point = island.collision[i];
                        if (i === 0) {
                            this.ctx.moveTo(point.x, point.y);
                        } else {
                            this.ctx.lineTo(point.x, point.y);
                        }
                    }
                    
                    this.ctx.closePath();
                    this.ctx.stroke();
                    
                    // Draw collision points
                    this.ctx.fillStyle = isSelected ? '#ffa502' : '#70a1ff';
                    for (let point of island.collision) {
                        this.ctx.beginPath();
                        this.ctx.arc(point.x, point.y, 4 / this.zoom, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                // Draw center point
                this.ctx.fillStyle = isSelected ? '#ff4757' : '#2ed573';
                this.ctx.beginPath();
                this.ctx.arc(island.x, island.y, 6 / this.zoom, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw coordinates
                this.ctx.fillStyle = '#95a5a6';
                this.ctx.font = `${12 / this.zoom}px monospace`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(
                    `(${Math.round(island.x)}, ${Math.round(island.y)})`,
                    island.x,
                    island.y + island.radius + 20 / this.zoom
                );
            }
            
            drawTempLine() {
                if (!this.selectedIsland || this.tempLinePoints.length === 0) return;
                
                this.ctx.strokeStyle = '#ff6348';
                this.ctx.lineWidth = 3 / this.zoom;
                this.ctx.setLineDash([10 / this.zoom, 5 / this.zoom]);
                
                this.ctx.beginPath();
                for (let i = 0; i < this.selectedIsland.collision.length; i++) {
                    const point = this.selectedIsland.collision[i];
                    if (i === 0) {
                        this.ctx.moveTo(point.x, point.y);
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                }
                
                // Line from last point to mouse
                if (this.selectedIsland.collision.length > 0) {
                    this.ctx.lineTo(this.mouse.worldX, this.mouse.worldY);
                }
                
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Draw temp points
                this.ctx.fillStyle = '#ff6348';
                for (let point of this.selectedIsland.collision) {
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, 5 / this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Draw current mouse position
                this.ctx.strokeStyle = '#ff6348';
                this.ctx.lineWidth = 2 / this.zoom;
                this.ctx.beginPath();
                this.ctx.arc(this.mouse.worldX, this.mouse.worldY, 8 / this.zoom, 0, Math.PI * 2);
                this.ctx.stroke();
            }
        }
        
        // Initialize World Builder
        const worldBuilder = new AdvancedWorldBuilder();
        
        // Auto-load default data
        setTimeout(() => {
            worldBuilder.loadFromServer();
        }, 1000);
    </script>
</body>
</html>